# [322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数**  。如果没有任何一种硬币组合能组成总金额，返回`-1` 。

你可以认为每种硬币的数量是无限的。

**示例1：** 

```
**输入：** coins = `[1, 2, 5]`, amount = `11`
**输出：** `3` 
**解释：** 11 = 5 + 5 + 1```

**示例 2：** 

```
**输入：** coins = `[2]`, amount = `3`
**输出：** -1```

**示例 3：** 

```
**输入：** coins = [1], amount = 0
**输出：** 0
```

**提示：** 

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

## Solutions:

1. 递归+记忆化搜索
2. 完全背包DP
3. 完全背包DP空间优化

## Code：

### 递归+记忆化搜索

```c++
class Solution {
public:
    // 定义 DFS 函数：
    // dfs(index, ans) 表示：
    // 在 coins[0..index] 范围内选择硬币，
    // 凑成金额 ans 所需的最少硬币数量。
    int dfs(vector<int>& coins, vector<vector<int>>& mem, int index, int ans) {
        // ✅ Base Case: 如果金额刚好为 0，则不需要任何硬币
        if(ans == 0){
            return 0;
        }
        // ✅ Base Case: 如果金额 < 0 或 没有硬币可选，返回一个极大值表示不可能
        else if(index < 0 || ans < 0){
            return INT_MAX / 2;  // 防止溢出
        }
        // ✅ 如果当前状态已计算过，直接返回缓存结果
        if(mem[index][ans] != -1) return mem[index][ans];

        // ✅ 两种选择：
        // 1️⃣ 不选当前硬币（转移到 index - 1）
        int not_take = dfs(coins, mem, index - 1, ans);
        // 2️⃣ 选择当前硬币一次（转移到 ans - coins[index]，但 index 不变，因为可以重复选）
        int take = dfs(coins, mem, index, ans - coins[index]) + 1;

        // ✅ 返回两者最小值，并存入记忆化数组
        return mem[index][ans] = min(not_take, take);
    }

    int coinChange(vector<int>& coins, int amount) {
        // 创建二维记忆化数组：
        // mem[index][ans] 表示在 0..index 硬币范围内凑出金额 ans 的最少硬币数
        // 初始化为 -1 表示未计算过
        vector<vector<int>> mem(coins.size(), vector<int>(amount + 1, -1));

        // 从 coins.size() - 1 (即最后一个硬币) 开始向下递归
        int result = dfs(coins, mem, coins.size() - 1, amount);

        // 如果结果小于 INT_MAX/2，说明可以凑出，返回最少硬币数；否则返回 -1 表示无解
        return result < INT_MAX / 2 ? result : -1;
    }
};

```

