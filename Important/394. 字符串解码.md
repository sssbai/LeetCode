# [394. 字符串解码](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像`3a`或`2[4]`的输入。

**示例 1：** 

```
**输入：** s = "3[a]2[bc]"
**输出：** "aaabcbc"
```

**示例 2：** 

```
**输入：** s = "3[a2[c]]"
**输出：** "accaccacc"
```

**示例 3：** 

```
**输入：** s = "2[abc]3[cd]ef"
**输出：** "abcabccdcdcdef"
```

**示例 4：** 

```
**输入：** s = "abc3[cd]xyz"
**输出：** "abccdcdcdxyz"
```

**提示：** 

- `1 <= s.length <= 30`
- `s`由小写英文字母、数字和方括号`'[]'` 组成
- `s`保证是一个**有效** 的输入。
- `s`中所有整数的取值范围为`[1, 300]`

## Solution

辅助栈+迭代法

辅助栈+递归法

## Code

### 辅助栈+迭代法

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<int> stn;         // 用于存放数字（重复次数）
        stack<string> sts;      // 用于存放前一个已构建的字符串（用于回溯）
        string res = "";        // 当前正在构建的字符串
        int count = 0;          // 当前的数字（重复次数）

        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '[') {
                // 遇到 '['，将当前重复次数和构建的字符串压栈
                stn.push(count);
                count = 0;      // 重置 count
                sts.push(res);
                res = "";       // 重置 res，开始构建括号内的新字符串
            }
            else if (s[i] == ']') {
                // 遇到 ']'，说明一个子串结束，开始拼接
                int num = stn.top(); stn.pop();       // 获取重复次数
                string tmps = sts.top(); sts.pop();   // 获取之前构建的字符串

                // 将当前 res 重复 num 次并拼接到之前的字符串后面
                while (num--) {
                    tmps += res;
                }

                // 更新当前的 res
                res = tmps;
            }
            else if (isdigit(s[i])) {
                // 构建多位数（例如“23”）
                count = count * 10 + (s[i] - '0');
            }
            else {
                // 普通字符，添加到当前字符串中
                res += s[i];
            }
        }

        return res;
    }
};

```

### 辅助栈+递归法

该方法我没有自己写，copy过来的

```c++
class Solution {
public:
string analysis(string s, int& index) {
    string res;
    int num = 0;
    string temp;
    while (index < s.size()) {
        if (s[index] >= '0' && s[index] <= '9') {
            num = 10 * num + s[index] - '0';
        }
        else if (s[index] == '[') {
            temp = analysis(s, ++index);//碰到'[',开始递归
            while(num-->0) res += temp;
            num = 0;//num置零
        }
        else if (s[index] == ']') break;//碰到']',结束递归
        else res += s[index];
        index++;
    }
    return res;
}
string decodeString(string s) {
    int index = 0;
    return analysis(s, index);
}
};

```



