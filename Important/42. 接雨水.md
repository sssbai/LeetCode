# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

给定`n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：** 

<img src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507311430953.png" style="height: 161px; width: 412px;">

```
**输入：** height = [0,1,0,2,1,0,1,3,2,1,2,1]
**输出：** 6
**解释：** 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：** 

```
**输入：** height = [4,2,0,3,2,5]
**输出：** 9
```

**提示：** 

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

## Solution

此题有两种解法，一种是双指针，分别为双指针，单调栈

双指针是计算桶的高度

单调栈是计算层的高度

## Code

单调栈

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;          // 存储最终接到的雨水总量
        stack<int> st;        // 单调栈，存储的是柱子的下标

        // 遍历每一个柱子
        for (int i = 0; i < height.size(); i++) {
            // 当前柱子高度大于栈顶柱子高度，说明可以形成凹槽（低 -> 高结构），可能接雨水
            while (!st.empty() && height[i] >= height[st.top()]) {
                int bottom_h = height[st.top()]; // 当前凹槽的底部高度
                st.pop();                        // 弹出凹槽底部

                // 如果栈为空，说明左边没有更高的柱子，无法形成凹槽
                if (st.empty()) {
                    break;
                }

                int left = st.top(); // 左边界的柱子下标
                int dh = min(height[left], height[i]) - bottom_h; 
                // 计算能装水的“高度”，即左右两边较矮者与底部之间的高度差

                int width = i - left - 1; // 计算能装水的“宽度”，即左右柱子之间的距离减去中间的底柱

                ans += dh * width; // 高 × 宽 = 面积，即雨水量
            }

            // 当前柱子下标入栈，作为后续雨水计算的候选
            st.push(i);
        }

        return ans; // 返回总的接雨水量
    }
};

```

