# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

二叉树中的** 路径**  被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次**  。该路径** 至少包含一个 ** 节点，且不一定经过根节点。

**路径和**  是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和**  。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507311152922.jpg" style="width: 322px; height: 182px;">

```
**输入：** root = [1,2,3]
**输出：** 6
**解释：** 最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6```

**示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg">

```
**输入：** root = [-10,9,20,null,null,15,7]
**输出：** 42
**解释：** 最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：** 

- 树中节点数目范围是 `[1, 3 * 10^4]`
- `-1000 <= Node.val <= 1000`
```

## Solution

树形DP

## Code

```c++
/**
 * Definition for a binary tree node.
 * 二叉树节点定义
 */
struct TreeNode {
    int val;                // 当前节点的值
    TreeNode *left;         // 指向左子节点的指针
    TreeNode *right;        // 指向右子节点的指针
    TreeNode() : val(0), left(nullptr), right(nullptr) {} // 默认构造函数
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 带值构造函数
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} // 全参构造函数
};

class Solution {
public:
    // 用于记录遍历过程中遇到的最大路径和
    int maxvalue = INT32_MIN;

    // 深度优先搜索，返回以当前节点为起点的最大单边路径和（不能拐弯）
    int dfs(TreeNode* node) {
        // 如果节点为空，返回0，不贡献路径和
        if (node == nullptr) {
            return 0;
        }

        // 递归求左子树和右子树的最大贡献值
        int leftvalue = dfs(node->left);
        int rightvalue = dfs(node->right);

        // 计算包含当前节点的路径和（可以从左到当前到右，即允许拐弯）
        // 也可以只取当前节点值（即左子树和右子树都为负时）
        maxvalue = max({
            maxvalue,                     // 当前最大值
            leftvalue + rightvalue + node->val, // 左右子树加当前节点（路径可以从左穿过当前到右）
            node->val                    // 只有当前节点值（左右子树均为负时）
        });

        // 返回以当前节点为起点的最大单边路径和（必须是从当前节点向下延伸）
        // 如果加上当前节点值仍然为负，则返回0（不选择该路径）
        return max(max(leftvalue, rightvalue) + node->val, 0);
    }

    // 主函数，返回整棵树中的最大路径和
    int maxPathSum(TreeNode* root) {
        dfs(root);             // 启动 DFS 遍历
        return maxvalue;       // 返回记录的最大路径和
    }
};

```

