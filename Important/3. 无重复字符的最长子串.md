# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个字符串 `s` ，请你找出其中不含有重复字符的**最长 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子串</button>** **** 的长度。

**示例1:** 

```
**输入: ** s = "abcabcbb"
**输出: ** 3 
**解释:**  因为无重复字符的最长子串是 `"abc"`，所以其长度为 3。
```

**示例 2:** 

```
**输入: ** s = "bbbbb"
**输出: ** 1
**解释: ** 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。
```

**示例 3:** 

```
**输入: ** s = "pwwkew"
**输出: ** 3
**解释: ** 因为无重复字符的最长子串是`"wke"`，所以其长度为 3。
    请注意，你的答案必须是 **子串 ** 的长度，`"pwke"`是一个子序列，不是子串。
```

**提示：** 

- `0 <= s.length <= 5 * 10^4`
- `s`由英文字母、数字、符号和空格组成

## Solution

滑动窗口，双指针

## Code

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();        // 字符串长度
        int ans = 0;               // 最长子串的长度
        int left = 0;              // 滑动窗口左指针
        unordered_map<char, int> cnt; // 哈希表，记录窗口中每个字符的出现次数

        // 枚举滑动窗口右端点
        for (int right = 0; right < n; right++) {
            char c = s[right];
            cnt[c]++; // 加入当前字符

            // 如果当前字符重复了，移动左指针直到不重复
            while (cnt[c] > 1) {
                cnt[s[left]]--; // 移除左侧字符
                left++;         // 左指针右移
            }

            // 更新最长长度
            ans = max(ans, right - left + 1);
        }

        return ans;
    }
};

```

