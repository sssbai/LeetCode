# [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组`nums1` 和`nums2`。请你找出并返回这两个正序数组的 **中位数**  。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：** 

```
**输入：** nums1 = [1,3], nums2 = [2]
**输出：** 2.00000
**解释：** 合并数组 = [1,2,3] ，中位数 2
```

**示例 2：** 

```
**输入：** nums1 = [1,2], nums2 = [3,4]
**输出：** 2.50000
**解释：** 合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**提示：** 

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## Solution

### 关键想法：**将问题转化为两个数组的切分问题**

中位数的定义：

* 如果总长度是奇数，中位数是中间的数；
  
* 如果是偶数，是中间两个数的平均。
  

假设两个数组长度分别为 `n` 和 `m`，我们设法在两个数组中切出一部分，使得：

* 左边的元素个数 = 右边的元素个数（总共偶数）；
  
* 或左边比右边多一个（总共奇数）；
  
* 同时，**左边的最大值 ≤ 右边的最小值**（确保中位数落在两侧之间）
  

* * *

### 为什么在**较短的数组**上进行二分？

假设我们在 `nums1` 上二分切分点 `cut1`，那么 `nums2` 的切分点 `cut2 = (n + m) - cut1`。这样保证：

* `cut1 + cut2 = n + m`，两侧总数量一致；
  
* 只需要在 `nums1` 上进行二分，复杂度是 O(log(min(n, m)))。
  

* * *

### 如何表示切分位置？

在奇偶统一处理下，我们引入了 **虚拟切分点**：

* 对每个元素之间都认为存在一个“虚拟”切分点；
  
* 比如数组 `[1, 2, 3]` 可视为 `[#, 1, #, 2, #, 3, #]`；
  
* 一共有 `2n + 1` 个切分点；
  
* 假设我们在 `cut1` 位置切开，就有 `cut1 / 2` 个元素在左边。
  

### 算法详细步骤如下：

1. **确保 nums1 是较短的数组**，方便我们在它上面二分；
   
2. 在虚拟数组 `[#, a1, #, a2, #, ..., an, #]` 上进行二分：
   
    * 虚拟数组长度为 `2n + 1`，切分点范围为 `[0, 2n]`；
    
3. 在每轮二分中，计算：
   
    * `cut1` 是 `nums1` 上的切分点；
      
    * `cut2 = (n + m) - cut1`；
    
4. 找到对应切分后的 4 个关键值：
   
    * `lmax1`：`nums1` 切分左边的最大值；
      
    * `rmin1`：`nums1` 切分右边的最小值；
      
    * `lmax2`：`nums2` 切分左边的最大值；
      
    * `rmin2`：`nums2` 切分右边的最小值；
    
5. 判断切分是否合理：
   
    * 如果 `lmax1 > rmin2`：说明 `cut1` 太大，需要往左移；
      
    * 如果 `lmax2 > rmin1`：说明 `cut1` 太小，需要往右移；
      
    * 如果都满足：找到正确切分；
    
6. 返回中位数：
   
    * `(max(lmax1, lmax2) + min(rmin1, rmin2)) / 2.0`

## Code

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int lmax1, lmax2, rmin1, rmin2;
        int n = nums1.size();
        int m = nums2.size();

        // 保证 nums1 是较短的数组，这样我们只在 nums1 上进行二分搜索
        if(n > m){
            swap(nums1, nums2);
            swap(n, m);
        }

        // 在虚拟的 nums1 上进行二分，虚拟数组长度为 2n + 1，故左右边界为 [0, 2n]
        int low = 0, high = 2 * n;

        while(low <= high){
            // cut1 表示在虚拟 nums1 上的切分位置
            int cut1 = low + (high - low) / 2;

            // cut2 保证 cut1 + cut2 = 2*(n + m)，即两个数组左边的总元素个数与右边相等
            int cut2 = m + n - cut1;

            // 处理 nums1 左边最大值
            if(cut1 == 0) 
                lmax1 = INT_MIN; // 如果切分点在最左边，则左边无元素，设为负无穷
            else 
                lmax1 = nums1[(cut1 - 1) / 2]; // cut1 是虚拟数组下标，所以要映射回实际数组

            // 处理 nums1 右边最小值
            if(cut1 == 2 * n) 
                rmin1 = INT_MAX; // 如果切分点在最右边，则右边无元素，设为正无穷
            else 
                rmin1 = nums1[cut1 / 2];

            // 处理 nums2 左边最大值
            if(cut2 == 0) 
                lmax2 = INT_MIN;
            else 
                lmax2 = nums2[(cut2 - 1) / 2];

            // 处理 nums2 右边最小值
            if(cut2 == 2 * m) 
                rmin2 = INT_MAX;
            else 
                rmin2 = nums2[cut2 / 2];

            // 检查切分是否满足条件：左边最大值 <= 右边最小值
            if(lmax1 > rmin2) {
                // lmax1 太大，说明 cut1 应该向左移动
                high = cut1 - 1;
            } else if(lmax2 > rmin1) {
                // lmax2 太大，说明 cut1 应该向右移动
                low = cut1 + 1;
            } else {
                // 满足条件，跳出循环
                break;
            }
        }

        // 中位数是左边最大值与右边最小值的平均
        return (max(lmax1, lmax2) + min(rmin1, rmin2)) / 2.0;
    }
};

```

