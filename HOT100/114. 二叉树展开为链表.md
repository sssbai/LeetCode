# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" target="_blank">**先序遍历** </a> 顺序相同。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508051959919.jpg" style="width: 500px; height: 226px;">

```
**输入：** root = [1,2,5,3,4,null,6]
**输出：** [1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：** 

```
**输入：** root = []
**输出：** []
```

**示例 3：** 

```
**输入：** root = [0]
**输出：** [0]
```

**提示：** 

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

## Solution

中序遍历

## Code

下面这个写法应该不算是原地修改

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* dummy = new TreeNode();  // 创建一个哑节点，用来辅助构建右子链
    TreeNode* cur = dummy;             // 当前构建到的节点指针

    // 深度优先遍历函数，按先序遍历的顺序“拉平”树
    void dfs(TreeNode* node){
        if (!node) return;             // 如果节点为空，直接返回

        cur->right = node;             // 将当前节点挂在cur的右边
        TreeNode* left = node->left;   // 保存当前节点的左子树
        TreeNode* right = node->right; // 保存当前节点的右子树

        node->left = nullptr;          // 清空左指针，符合链表结构
        node->right = nullptr;         // 暂时清空右指针，避免后续连接错误

        cur = cur->right;              // cur 指向当前节点

        dfs(left);                     // 先递归处理左子树
        dfs(right);                    // 再递归处理右子树
    }

    // 主函数，入口
    void flatten(TreeNode* root) {
        dfs(root);                     // 从根节点开始递归拉平
    }
};

```

### 最佳原地操作

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 辅助函数：对当前 node 为根的子树进行“拉平”，返回拉平后链表的尾节点
    TreeNode* dfs(TreeNode* node){
        if(!node) return nullptr;  // 空节点直接返回

        // 递归处理左子树和右子树
        TreeNode* left_tail = dfs(node->left);   // 拉平左子树，返回左子树链表的尾节点
        TreeNode* right_tail = dfs(node->right); // 拉平右子树，返回右子树链表的尾节点

        // 如果存在左子树，需要把左子树插入到右子树的位置
        if(left_tail){
            left_tail->right = node->right; // 将原右子树接到左子树链表的尾部
            node->right = node->left;       // 将左子树整体放到右子树位置
            node->left = nullptr;           // 清空左子树指针（因为链表结构不允许左指针）
        }

        // 返回当前子树 flatten 后的最后一个节点（尾节点）
        if(right_tail) return right_tail;   // 优先返回右子树的尾节点
        else if(left_tail) return left_tail; // 如果没有右子树，返回左子树的尾节点
        else return node;                   // 如果左右子树都没有，当前节点就是尾节点
    }

    // 主函数：flatten 二叉树入口
    void flatten(TreeNode* root) {
        dfs(root);  // 从根节点开始 flatten 操作
    }
};

```

