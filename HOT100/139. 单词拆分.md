# [139. 单词拆分](https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s`则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：** 

```
**输入:**  s = "leetcode", wordDict = ["leet", "code"]
**输出:**  true
**解释:**  返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：** 

```
**输入:**  s = "applepenapple", wordDict = ["apple", "pen"]
**输出:**  true
**解释:**  返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
    注意，你可以重复使用字典中的单词。
```

**示例 3：** 

```
**输入:**  s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
**输出:**  false
```

**提示：** 

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

## Solutions

1. 记忆化搜索+递归
2. DP动态规划

## Codes:

```c++
class Solution {
public:
    unordered_set<string> wordset; // 用于快速判断单词是否在字典中
    int max_len; // 字典中最长单词的长度，用于剪枝

    // DFS + 记忆化搜索：从 s[0..j] 能否被 wordDict 中的单词完全拆分
    bool dfs(const string& s, vector<int>& mem, int j) {
        if (j < 0) {
            return true; // 成功拆分完所有字符
        }
        if (mem[j] != -1) {
            return mem[j]; // 如果已计算过，直接返回结果（1:true, 0:false）
        }

        bool tag = false; // 当前状态是否可拆分
        // 尝试使用长度为 1..max_len 的单词结尾匹配 s[0..j]
        for (int i = 0; i < max_len && j - i >= 0; i++) {
            // 判断 s[j-i..j] 是否在字典中
            if (wordset.find(s.substr(j - i, i + 1)) != wordset.end()) {
                // 如果前面的部分也能被拆分，则当前可拆分，直接返回
                if (dfs(s, mem, j - i - 1)) {
                    tag = true;
                    break; // 找到即可，不需要继续尝试更长单词
                }
            }
        }
        mem[j] = tag; // 记录当前状态是否可拆分
        return tag;
    }

    bool wordBreak(string s, vector<string>& wordDict) {
        // 将 wordDict 放入哈希集合方便 O(1) 查询
        wordset = unordered_set<string>(wordDict.begin(), wordDict.end());

        // 预先计算字典中最长单词长度，用于剪枝
        max_len = 0;
        for (auto& w : wordDict) {
            max_len = max(max_len, (int)w.size());
        }

        // mem[i]: 表示 s[0..i] 是否可被完全拆分
        // -1: 未访问过；0: 不可拆分；1: 可拆分
        vector<int> mem(s.size(), -1);

        // 从 s[0..n-1] 开始递归判断
        return dfs(s, mem, s.size() - 1);
    }
};

```

