# [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508071014987.jpg" style="width: 422px; height: 222px;">

```
**输入：** head = [1,2,3,4]
**输出：** [2,1,4,3]
```

**示例 2：** 

```
**输入：** head = []
**输出：** []
```

**示例 3：** 

```
**输入：** head = [1]
**输出：** [1]
```

**提示：** 

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

## Solution

交换结点

## Code

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* pre = dummy;
        ListNode* cur = head;
        while(cur&&cur->next){
            ListNode* tmp = cur->next;
            cur->next = cur->next->next;
            pre->next = tmp;
            tmp->next = cur;
            pre = cur;
            cur = cur->next;
        }
        return dummy->next;
    }
};
```

