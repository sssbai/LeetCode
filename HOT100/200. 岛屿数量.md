# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个由`'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：** 

```
**输入：** grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
**输出：** 1
```

**示例 2：** 

```
**输入：** grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
**输出：** 3
```

**提示：** 

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

## Solution

DFS

## Code

```c++
class Solution {
public:
    int n, m; // 用于存储网格的行数和列数
    vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; // 定义四个方向：下、右、上、左

    // 深度优先搜索函数，用于沉没连接的一整块陆地
    void dfs(vector<vector<char>>& grid, int x, int y) {
        grid[x][y] = '0'; // 将访问过的陆地标记为水，避免重复访问
        for (int i = 0; i < 4; i++) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            // 检查新位置是否在网格范围内，并且是陆地
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '1') {
                dfs(grid, nx, ny); // 递归访问相邻陆地
            }
        }
    }

    // 主函数，统计岛屿数量
    int numIslands(vector<vector<char>>& grid) {
        n = grid.size();         // 获取网格的行数
        m = grid[0].size();      // 获取网格的列数
        int count = 0;           // 记录岛屿的数量

        // 遍历整个网格
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 如果遇到陆地，则从该点开始 DFS，并将整块陆地沉没
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++; // 每次DFS完成，说明找到一个完整岛屿
                }
            }
        }

        return count; // 返回岛屿数量
    }
};

```



