# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为`O(n)` 的算法解决此问题。

**示例 1：** 

```
**输入：** nums = [100,4,200,1,3,2]
**输出：** 4
**解释：** 最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。```

**示例 2：** 

```
**输入：** nums = [0,3,7,2,5,8,4,6,0,1]
**输出：** 9
```

<strong class="example">示例 3：** 

```
**输入：** nums = [1,0,1,2]
<b>输出：</b>3
```

**提示：** 

- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
```

## Solution

哈希，对集合进行遍历，找到起始元素后在开始累加

## Code

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 将数组中的所有元素放入 unordered_set，去重并加快查找速度（O(1) 时间复杂度）
        unordered_set<int> uset(nums.begin(), nums.end());
        int mx = 0; // 用于记录最长连续序列的长度

        // 遍历 set 中的每一个元素 x
        for(auto x: uset){
            // 如果 x-1 存在于 set 中，说明 x 不是某个连续序列的起点，跳过
            if(uset.contains(x - 1)){
                continue;
            }

            // 从 x 开始查找连续序列的长度
            int y = x + 1;
            while(uset.contains(y)){
                y += 1;
            }

            // 更新最大连续长度
            mx = max(mx, y - x);

            // 提前退出优化：
            // 如果当前找到的最大长度的两倍已经大于等于 set 的大小，
            // 那么就不可能有更长的序列了，可以提前退出
            if(2 * mx >= uset.size()) break;
        }

        // 返回最长连续序列的长度
        return mx;
    }
};

```

