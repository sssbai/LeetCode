# [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：** 

```
**输入：** nums = [1,2,0]
**输出：** 3
**解释：** 范围 [1,2] 中的数字都在数组中。```

**示例 2：** 

```
**输入：** nums = [3,4,-1,1]
**输出：** 2
**解释：** 1 在数组中，但 2 没有。```

**示例 3：** 

```
**输入：** nums = [7,8,9,11,12]
**输出：** 1
**解释：** 最小的正数 1 没有出现。```

**提示：** 

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
```

## Solution

换座位思想：可以将数组视为哈希表，每次将对应的数值更新到对应的数组位置

## Code

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();

        // 第一轮遍历：将每个正整数 x 放到索引 x-1 的位置上
        for (int i = 0; i < n; i++) {
            // 当 nums[i] 是有效的正整数，且不在正确的位置上时，交换它和其目标位置的值
            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                // 交换 nums[i] 和 nums[nums[i] - 1]，把 nums[i] 放到正确的位置上
                swap(nums[i], nums[nums[i] - 1]);
            }
        }

        // 第二轮遍历：找第一个 nums[i] != i + 1 的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                // i + 1 是缺失的最小正整数
                return i + 1;
            }
        }

        // 如果前 n 个位置都放了正确的值，那么缺失的是 n + 1
        return n + 1;
    }
};

```

