# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k** ` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:** 

```
**输入:**  `[3,2,1,5,6,4],` k = 2
**输出:**  5
```

**示例2:** 

```
**输入:**  `[3,2,3,1,2,4,5,5,6], `k = 4
**输出:**  4```

**提示： ** 

- `1 <= k <= nums.length <= 10^5`
- `-10^4<= nums[i] <= 10^4`
```

## Solutions

1. 采用快排进行排序后，直接输出结果，但是这种设计无法通过面试
2. 采用部分快排来进行排序，进行输出
   1. 采用分区法：标准hoare方法，左右指针方法，挖坑法
   2. 采用lomuto方法：前后指针方法
3. 采用桶排序方法
4. 采用堆排序

## Code

### 1 左右指针

```c++
class Solution {
public:
    // 快速选择递归函数，返回第 k 大的元素
    int dfs(vector<int>& nums, int k, int start, int end) {
        int left = start;
        int right = end;
        int pivot = nums[left]; // 选择起始位置的元素作为基准

        // 快速排序的 partition 过程
        while (left < right) {
            // 从右往左找第一个比 pivot 大的元素
            while (left < right && nums[right] <= pivot) {
                right--;
            }
            // 从左往右找第一个比 pivot 小的元素
            while (left < right && nums[left] >= pivot) {
                left++;
            }
            swap(nums[left], nums[right]); // 交换
        }

        // 将 pivot 放回最终归位的位置
        swap(nums[left], nums[start]);

        // 判断 pivot 的位置是否是第 k 大
        if (left < k - 1) {
            // 第 k 大在右侧
            return dfs(nums, k, left + 1, end);
        } else if (left > k - 1) {
            // 第 k 大在左侧
            return dfs(nums, k, start, left - 1);
        } else {
            // 找到第 k 大
            return nums[left];
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        return dfs(nums, k, 0, nums.size() - 1);
    }
};

```

