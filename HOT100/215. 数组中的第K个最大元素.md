# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k** ` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:** 

```
**输入:**  `[3,2,1,5,6,4],` k = 2
**输出:**  5
```

**示例2:** 

```
**输入:**  `[3,2,3,1,2,4,5,5,6], `k = 4
**输出:**  4```

**提示： ** 

- `1 <= k <= nums.length <= 10^5`
- `-10^4<= nums[i] <= 10^4`
```

## Solutions

1. 采用快排进行排序后，直接输出结果，但是这种设计无法通过面试
2. 采用部分快排来进行排序，进行输出
   1. 采用分区法：标准hoare方法，左右指针方法，挖坑法
   2. 采用lomuto方法：前后指针方法
3. 采用桶排序方法
4. 采用堆排序

## Code

### 1 左右指针

```c++
class Solution {
public:
    int getkn(vector<int>& nums, int k, int start, int end){
        int left = start;
        int right = end;
        int pivot = nums[left];
        while(left<right){
            // cout<<left<<" "<<right<<endl;
            while(left<right&&nums[right]<=pivot){
                right--;
            }
            while(left<right&&nums[left]>=pivot){
                left++;
            }
            swap(nums[left], nums[right]);      
        }
        // cout<<left<<" "<<pivot<<endl;
        swap(nums[start], nums[left]);
        if(left==k-1){
            return nums[left];
        }
        else if(left<k-1){
            return getkn(nums, k, left+1, end);
        }
        else{
            return getkn(nums, k, start, left-1);
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        return getkn(nums, k, 0, nums.size()-1);
    }
};
```

