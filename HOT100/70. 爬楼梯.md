# [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked)

假设你正在爬楼梯。需要 `n`阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：** 

```
**输入：** n = 2
**输出：** 2
**解释：** 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶```

**示例 2：** 

```
**输入：** n = 3
**输出：** 3
**解释：** 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：** 

- `1 <= n <= 45`
```

## Solutions

1. 动态规划
2. 记忆化搜索

## Codes

### 记忆化搜索

```c++
class Solution {
public:
    // 带记忆化数组 mem 的递归函数 dfs(i)，返回爬到第 i 层楼梯的不同方法数
    int dfs(int i, vector<int>& mem) {
        // 如果 i <= 1，只能有 1 种爬法（到达第 0 层或第 1 层）
        if (i <= 1) {
            return 1;
        }

        // 如果 mem[i] 已经计算过，直接返回，避免重复递归
        if (mem[i]) return mem[i];

        // 递归计算：到达第 i 层的方法 = 到达第 (i-1) 层的方法 + 到达第 (i-2) 层的方法
        // 因为每次只能爬 1 或 2 个台阶
        int count = dfs(i - 1, mem) + dfs(i - 2, mem);

        // 记忆化当前结果，避免重复计算
        mem[i] = count;

        return count;
    }

    // 主函数，返回爬 n 层台阶的不同方法数
    int climbStairs(int n) {
        // 初始化记忆化数组 mem，长度 n+1，初值为 0，表示未计算过
        vector<int> mem(n + 1, 0);
        // 从第 n 层开始递归计算
        return dfs(n, mem);
    }
};

```

### 动态规划

```c++
class Solution {
public:
    int climbStairs(int n) {
        // dp[i] 表示爬到第 i 层台阶的不同方法数
        vector<int> dp(n + 1, 0);

        // 初始状态：
        dp[0] = 1;  // 爬到第 0 层只有 1 种方式（不爬）
        dp[1] = 1;  // 爬到第 1 层只有 1 种方式（爬 1 步）

        // 状态转移：
        // 对于每一层 i，到达它的方法 = 到达 (i-1) 层的方法 + 到达 (i-2) 层的方法
        // 因为每次只能爬 1 或 2 步
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // 返回到达第 n 层的方法总数
        return dp[n];
    }
};

```

