# [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个 `m` 行 `n` 列的矩阵`matrix` ，请按照 **顺时针螺旋顺序**  ，返回矩阵中的所有元素。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508062314859.jpg" style="width: 242px; height: 242px;">

```
**输入：** matrix = [[1,2,3],[4,5,6],[7,8,9]]
**输出：** [1,2,3,6,9,8,7,4,5]
```

**示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;">

```
**输入：** matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
**输出：** [1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：** 

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

## Solution

这题的关键是方向取模转弯

## Code

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 四个方向：右、下、左、上，顺时针旋转
        // direction[i] 表示当前方向 x 和 y 的增量
        vector<vector<int>> direction = {
            {0, 1},   // 向右
            {1, 0},   // 向下
            {0, -1},  // 向左
            {-1, 0}   // 向上
        };

        int n = matrix.size();      // 行数
        int m = matrix[0].size();   // 列数

        vector<int> ans(m * n);     // 最终返回结果，包含所有元素
        int x = 0, y = 0;           // 起始坐标
        int di = 0;                 // 当前方向的索引（初始为 0，即向右）

        for (int i = 0; i < m * n; i++) {
            ans[i] = matrix[x][y];      // 收集当前元素
            matrix[x][y] = INT32_MAX;   // 标记为访问过，避免重复访问

            // 计算下一个位置
            int tmpx = x + direction[di][0];
            int tmpy = y + direction[di][1];

            // 如果越界或下一个位置已经访问过，则需要转弯
            if (tmpx < 0 || tmpy < 0 || tmpx >= n || tmpy >= m || matrix[tmpx][tmpy] == INT32_MAX) {
                di = (di + 1) % 4; // 顺时针转弯，方向加 1 取模
            }

            // 根据当前方向移动坐标
            x += direction[di][0];
            y += direction[di][1];
        }

        return ans;
    }
};

```

