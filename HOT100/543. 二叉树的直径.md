# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一棵二叉树的根节点，返回该树的 **直径**  。

二叉树的 **直径**  是指树中任意两个节点之间最长路径的 **长度**  。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度**  由它们之间边数表示。

<strong class="example">示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508050957540.jpg" style="width: 292px; height: 302px;">

```
**输入：** root = [1,2,3,4,5]
**输出：** 3
**解释：** 3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

<strong class="example">示例 2：** 

```
**输入：** root = [1,2]
**输出：** 1
```

**提示：** 

- 树中节点数目在范围 `[1, 10^4]` 内
- `-100 <= Node.val <= 100`

## Solution

树形DP

## Code

```c++
/**
 * Definition for a binary tree node.
 * 定义二叉树节点的结构体
 */
struct TreeNode {
    int val;                // 节点的值
    TreeNode *left;         // 左子节点指针
    TreeNode *right;        // 右子节点指针
    TreeNode() : val(0), left(nullptr), right(nullptr) {} // 无参构造函数，默认值为0
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 仅设置节点值
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} // 设置值和左右子节点
};

class Solution {
public:
    int maxlen = 0;  // 记录当前遍历过程中遇到的最大直径（最长路径上的边数）

    // 深度优先搜索，用于计算每个节点的左右子树的最大深度
    int dfs(TreeNode* node){
        if(!node) return 0; // 空节点返回0，表示深度为0

        int left = dfs(node->left);   // 递归计算左子树的深度
        int right = dfs(node->right); // 递归计算右子树的深度

        maxlen = max(maxlen, left + right); // 更新最大直径（左深度 + 右深度）

        return max(left, right) + 1; // 返回当前节点为根时的最大深度
    }

    // 主函数，返回二叉树的直径
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);        // 启动深度优先搜索
        return maxlen;    // 返回最终求得的最大直径
    }
};

```

