# [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个`m x n` 的矩阵，如果一个元素为 **0 ** ，则将其所在行和列的所有元素都设为 **0**  。请使用 **<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a>**  算法**。** 

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508070845525.jpg" style="width: 450px; height: 169px;">

```
**输入：** matrix = [[1,1,1],[1,0,1],[1,1,1]]
**输出：** [[1,0,1],[0,0,0],[1,0,1]]
```

**示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" style="width: 450px; height: 137px;">

```
**输入：** matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
**输出：** [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**提示：** 

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-2^31 <= matrix[i][j] <= 2^31 - 1`

**进阶：** 

- 一个直观的解决方案是使用 `O(mn)`的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(m+n)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

## Solution

`O(m+n)`的解法，使用两个集合就行了

`O(1)`的解法，使用第一行第一列来记录

## Code

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        unordered_set<int> col, row;
        int cols = matrix[0].size(), rows = matrix.size();
        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0; j < matrix[0].size(); j++){
                if(matrix[i][j]==0){
                    row.insert(i);
                    col.insert(j);
                }
            }
        }
        for(auto v: row){
            for(int i = 0; i < cols; i++){
                matrix[v][i]=0;
            }
        }
        for(auto v: col){
            for(int i = 0; i < rows; i++){
                matrix[i][v]=0;
            }
        }
    }
};
```



