# [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个包含非负整数的 `mxn`网格`grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

<strong class="example">示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507271502799.jpg" style="width: 242px; height: 242px;">

```
**输入：** grid = [[1,3,1],[1,5,1],[4,2,1]]
**输出：** 7
**解释：** 因为路径 1→3→1→1→1 的总和最小。
```

<strong class="example">示例 2：** 

```
**输入：** grid = [[1,2,3],[4,5,6]]
**输出：** 12
```

**提示：** 

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## 二维动态规划

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> steps(m, vector<int>(n,0));
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i==0&&j==0){
                    steps[i][j]=grid[i][j];
                }
                else if(i==0&&j!=0){
                    steps[i][j] = steps[i][j-1]+grid[i][j];
                }
                else if(i!=0&&j==0){
                    steps[i][j] = steps[i-1][j]+grid[i][j];
                }
                else{
                    steps[i][j] = min(steps[i-1][j], steps[i][j-1]) + grid[i][j];
                }
            }
        }
        return steps[m-1][n-1];
    }
};
```

