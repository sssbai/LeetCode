# [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你** 不触动警报装置的情况下 ** ，一夜之内能够偷窃到的最高金额。

**示例 1：** 

```
**输入：** [1,2,3,1]
**输出：** 4
**解释：** 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
    偷窃到的最高金额 = 1 + 3 = 4 。```

**示例 2：** 

```
**输入：** [2,7,9,3,1]
**输出：** 12
**解释：** 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
    偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：** 

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`
```

## Solutions

1. 记忆化递推
2. 动态规划（空间优化）

## Codes

```c++
class Solution {
public:
    // dfs(n) 表示偷 [0..n] 房子能偷到的最大金额
    // 状态转移方程：
    // dfs(n) = max(dfs(n-1), dfs(n-2) + nums[n])
    // 表示要么不偷第 n 个房子（则考虑 n-1），要么偷第 n 个房子（则考虑 n-2）

    int dfs(vector<int>& nums, vector<int>& mem, int n) {
        if (n < 0) {
            return 0; // 如果索引小于 0，无房可偷，返回 0
        }
        if (mem[n] != -1) return mem[n]; // 如果已经计算过，直接返回记忆化结果

        // 计算不偷第 n 间房 vs 偷第 n 间房的最大值
        int result = max(
            dfs(nums, mem, n - 1),          // 不偷第 n 间
            dfs(nums, mem, n - 2) + nums[n] // 偷第 n 间，加上当前金额
        );

        mem[n] = result; // 记忆化结果
        return result;
    }

    int rob(vector<int>& nums) {
        // 初始化记忆化数组，长度等于房子数量，初值为 -1 表示未计算
        vector<int> mem(nums.size(), -1);

        // 从最后一个房子开始递归计算
        return dfs(nums, mem, nums.size() - 1);
    }
};

```



