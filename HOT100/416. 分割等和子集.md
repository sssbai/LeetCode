# [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums`，请你找出数组中乘积最大的非空连续 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子数组</button>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个**32-位**  整数。

<strong class="example">示例 1:** 

```
**输入:**  nums = [2,3,-2,4]
**输出:**  `6`
**解释:** 子数组 [2,3] 有最大乘积 6。
```

<strong class="example">示例 2:** 

```
**输入:**  nums = [-2,0,-1]
**输出:**  0
**解释:** 结果不能为 2, 因为 [-2,-1] 不是子数组。```

**提示:** 

- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位**  整数
```

## Solutions:

这是一道01背包问题

1. 动态规划

## Codes：

### 动态规划写法

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // dp[i+1][j] 表示前 i 个数（下标 0~i）的子集中，是否可以选出若干数，使它们的和为 j
        // 状态转移：
        // 1. 不选第 i 个数：dp[i+1][j] = dp[i][j]
        // 2. 选第 i 个数：dp[i+1][j] = dp[i][j - nums[i]]

        int n = nums.size();

        // 计算所有元素的总和
        int s = reduce(nums.begin(), nums.end());

        // 如果总和为奇数，不可能分成两个相等的子集
        if (s % 2) return false;

        // 我们只需要找到一个子集，其和为总和的一半
        s /= 2;

        // dp[i][j] 表示前 i 个元素中，是否存在和为 j 的子集
        // 初始化为 false，维度为 (n+1) x (s+1)
        vector<vector<bool>> dp(n + 1, vector<bool>(s + 1, false));

        // 初始状态：不选任何元素时，总和为 0 是可以实现的
        dp[0][0] = true;

        // 遍历每个数
        for (int i = 0; i < n; i++) {
            // 遍历所有可能的目标和 j（从 1 到 s）
            for (int j = 1; j <= s; j++) {
                if (j >= nums[i]) {
                    // 1. 不选当前 nums[i]：dp[i][j]
                    // 2. 选当前 nums[i]：dp[i][j - nums[i]]
                    dp[i + 1][j] = dp[i][j] || dp[i][j - nums[i]];
                } else {
                    // 当前 nums[i] 太大，不能选，只能继承不选的状态
                    dp[i + 1][j] = dp[i][j];
                }
            }
        }

        // 返回是否可以从前 n 个数中选出若干个，使它们的和恰好为 s
        return dp[n][s];
    }
};

```

### 记忆化搜索

```c++
class Solution {
public:
    // 二维记忆数组：mem[i][s] 表示考虑前 i 个元素，是否能凑出和为 s
    vector<vector<int>> mem;

    // 递归函数：判断前 i 个元素能否组成和为 s
    bool dfs(vector<int>& nums, int i, int s) {
        // 递归终止条件：已经没有可选的数了
        if (i < 0) {
            // 如果目标和刚好为 0，说明找到合法子集，返回 true
            return s == 0;
        }

        // 记忆化：如果之前计算过，直接返回结果
        int& res = mem[i][s];
        if (res != -1) return res;

        if (s < nums[i]) {
            // 当前数太大，不能选，只能尝试不选
            return res = dfs(nums, i - 1, s);
        } else {
            // 两种选择：
            // 1. 不选 nums[i]，从前 i-1 个数中凑出和 s
            // 2. 选 nums[i]，从前 i-1 个数中凑出和 s - nums[i]
            return res = dfs(nums, i - 1, s) || dfs(nums, i - 1, s - nums[i]);
        }
    }

    bool canPartition(vector<int>& nums) {
        int n = nums.size();

        // 计算总和
        int s = reduce(nums.begin(), nums.end());

        // 如果总和是奇数，无法平分
        if (s % 2) return false;

        // 我们只需要判断能否找到和为总和一半的子集
        s /= 2;

        // 初始化记忆数组，值为 -1 表示未计算
        mem = vector<vector<int>>(n, vector<int>(s + 1, -1));

        // 从最后一个数（下标 n-1）开始递归查找
        return dfs(nums, n - 1, s);
    }
};

```

