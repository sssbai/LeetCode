# [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ `k` é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº**  è¿”å›ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 1:** 

```
**è¾“å…¥: ** nums = [1,1,1,2,2,3], k = 2
**è¾“å‡º: ** [1,2]
```

**ç¤ºä¾‹ 2:** 

```
**è¾“å…¥: ** nums = [1], k = 1
**è¾“å‡º: ** [1]```

**æç¤ºï¼š** 

- `1 <= nums.length <= 10^5`
- `k` çš„å–å€¼èŒƒå›´æ˜¯ `[1, æ•°ç»„ä¸­ä¸ç›¸åŒçš„å…ƒç´ çš„ä¸ªæ•°]`
- é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°ç»„ä¸­å‰ `k` ä¸ªé«˜é¢‘å…ƒç´ çš„é›†åˆæ˜¯å”¯ä¸€çš„

**è¿›é˜¶ï¼š** ä½ æ‰€è®¾è®¡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ **å¿…é¡»**  ä¼˜äº `O(n log n)` ï¼Œå…¶ä¸­ `n`æ˜¯æ•°ç»„å¤§å°ã€‚
```

## Solutions

1. priority_queue + å°æ ¹å †ç­–ç•¥
2. priority_queue + å¤§æ ¹å †ç­–ç•¥
3. æ‰‹åŠ¨å®ç°å°æ ¹å †
4. æ¡¶æ’åºç­–ç•¥
5. åŠå¿«æ’ç­–ç•¥

## Code

### priority_queue + å°æ ¹å †ç­–ç•¥

å®˜æ–¹å†™æ³•ï¼š

```c++
class Solution {
public:
    // æ¯”è¾ƒå‡½æ•°ï¼Œç”¨äº priority_queue æ„å»ºå°æ ¹å †ï¼ˆå †é¡¶æ˜¯é¢‘ç‡æœ€å°çš„å…ƒç´ ï¼‰
    struct cmp {
        bool operator()(pair<int, int>& a, pair<int, int>& b) {
            return a.second > b.second; 
            // è¿”å› true è¡¨ç¤º b ä¼˜å…ˆçº§é«˜äº aï¼Œå› æ­¤ä¼šå°† second å°çš„æ”¾åœ¨å †é¡¶
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        // ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡
        unordered_map<int, int> record;
        for (int num : nums) {
            record[num]++;
        }

        // å°æ ¹å †ï¼Œå®¹é‡å›ºå®šä¸º k
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq;

        for (auto [num, count] : record) {
            if (pq.size() < k) {
                // å †æœªæ»¡ï¼Œç›´æ¥æ’å…¥
                pq.push({num, count});
            } else {
                // å †å·²æ»¡
                if (pq.top().second < count) {
                    // è‹¥å½“å‰å…ƒç´ é¢‘ç‡å¤§äºå †é¡¶ï¼ˆæœ€å°é¢‘ç‡ï¼‰ï¼Œåˆ™å¼¹å‡ºå †é¡¶å¹¶æ’å…¥å½“å‰å…ƒç´ 
                    pq.pop();
                    pq.push({num, count});
                }
                // è‹¥å½“å‰å…ƒç´ é¢‘ç‡ <= å †é¡¶ï¼Œä¸åšä»»ä½•æ“ä½œ
            }
        }

        // ä»å †ä¸­ä¾æ¬¡å–å‡ºå…ƒç´ ï¼Œæ”¶é›†ç»“æœ
        vector<int> result;
        while (!pq.empty()) {
            result.push_back(pq.top().first); // åªå–å…ƒç´ å€¼
            pq.pop();
        }

        // å¦‚æœé¢˜ç›®éœ€è¦ä»é«˜åˆ°ä½è¿”å›ï¼Œå¯åœ¨æ­¤åè½¬ç»“æœ
        // reverse(result.begin(), result.end());

        return result;
    }
};

```

### priority_queue + å°æ ¹å †ç­–ç•¥

```c++
class Solution {
public:
    // æ¯”è¾ƒå‡½æ•°ï¼Œç”¨äº priority_queue æ„å»ºå¤§æ ¹å †ï¼ˆå †é¡¶æ˜¯é¢‘ç‡æœ€å¤§çš„å…ƒç´ ï¼‰
    struct cmp {
        bool operator()(pair<int, int>& a, pair<int, int>& b) {
            return a.second < b.second; // å¤§æ ¹å †ï¼šé¢‘ç‡å¤§çš„ä¼˜å…ˆçº§é«˜
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> record;
        // ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡
        for (int num : nums) {
            record[num]++;
        }

        // å¤§æ ¹å †ï¼Œå­˜å‚¨ <num, count>ï¼ŒæŒ‰ count ä»å¤§åˆ°å°æ’åº
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq;
        for (auto [num, count] : record) {
            pq.push({num, count});
        }

        vector<int> result;
        int i = 0;
        // å–å‡ºå †é¡¶å‰ k ä¸ªå…ƒç´ ï¼Œå³é¢‘ç‡æœ€é«˜çš„ k ä¸ªå…ƒç´ 
        while (!pq.empty() && i < k) {
            i++;
            result.push_back(pq.top().first); // åªä¿å­˜å…ƒç´ 
            pq.pop();
        }
        return result;
    }
};

```

### æ‰‹åŠ¨å®ç°å°æ ¹å †

```c++
class Solution {
public:
    vector<pair<int, int>> pq; // å°æ ¹å †ï¼Œç»´æŠ¤ size = k

    void insert_pq(int num, int count, int k) {
        if (pq.size() < k) {
            // å †æœªæ»¡ï¼Œç›´æ¥æ’å…¥å¹¶å‘ä¸Šè°ƒæ•´
            pq.emplace_back(num, count);//è¿™ç§æ’å…¥æ— éœ€åˆ›å»ºæ–°çš„å¯¹è±¡
            int idx = pq.size() - 1;
            while (idx > 0) {
                int parent = (idx - 1) / 2;
                if (pq[parent].second > pq[idx].second) {
                    swap(pq[parent], pq[idx]);
                    idx = parent;
                } else {
                    break;
                }
            }
        } else {
            // å †å·²æ»¡ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ›¿æ¢å †é¡¶
            if (pq[0].second < count) {
                pq[0] = {num, count}; // æ›¿æ¢å †é¡¶
                // å‘ä¸‹è°ƒæ•´
                int idx = 0;
                int n = pq.size();
                while (true) {
                    int left = 2 * idx + 1;
                    int right = 2 * idx + 2;
                    int smallest = idx;
                    if (left < n && pq[left].second < pq[smallest].second) {
                        smallest = left;
                    }
                    if (right < n && pq[right].second < pq[smallest].second) {
                        smallest = right;
                    }
                    if (smallest != idx) {
                        swap(pq[idx], pq[smallest]);
                        idx = smallest;
                    } else {
                        break;
                    }
                }
            }
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        pq.clear(); // ğŸš© ä¿®å¤å¤šç»„æµ‹è¯•æ—¶æœªæ¸…ç©ºçš„é—®é¢˜

        unordered_map<int, int> freq_map;
        for (int num : nums) {
            freq_map[num]++;
        }

        for (const auto& [num, count] : freq_map) {
            insert_pq(num, count, k);
        }

        vector<int> result;
        for (const auto& p : pq) {
            result.push_back(p.first);
        }

        // å¦‚æœéœ€è¦è¿”å›æŒ‰é¢‘ç‡ä»é«˜åˆ°ä½æ’åºï¼Œå¯å¯ç”¨ä»¥ä¸‹æ’åº
        // sort(result.begin(), result.end(), [&](int a, int b) {
        //     return freq_map[a] > freq_map[b];
        // });

        return result;
    }
};

```

### æ¡¶æ’åºç­–ç•¥

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();

        // åˆ›å»º n+1 ä¸ªæ¡¶ï¼Œæ¡¶ä¸‹æ ‡è¡¨ç¤ºå‡ºç°æ¬¡æ•°
        // buckets[f] ä¸­å­˜å‚¨æ‰€æœ‰å‡ºç°æ¬¡æ•°ä¸º f çš„å…ƒç´ 
        vector<vector<int>> buckets(n + 1);

        // ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°
        unordered_map<int, int> freq_map;
        for(int num : nums){
            freq_map[num]++;
        }

        // æ ¹æ®å‡ºç°æ¬¡æ•°å°†å…ƒç´ æ”¾å…¥å¯¹åº”æ¡¶ä¸­
        for(auto& [num, freq] : freq_map){
            buckets[freq].push_back(num);
        }

        vector<int> result;
        // ä»å‡ºç°æ¬¡æ•°æœ€å¤š (n) çš„æ¡¶å¼€å§‹éå†ï¼Œå‘ä¸‹æ‰¾å‡ºç°æ¬¡æ•°è¾ƒå°‘çš„æ¡¶
        for(int freq = n; freq >= 0 && result.size() < k; freq--){
            // éå†å½“å‰æ¡¶ä¸­çš„æ¯ä¸ªå…ƒç´ 
            for(int num : buckets[freq]){
                result.push_back(num);
                // æ‰¾åˆ° k ä¸ªåç«‹å³è¿”å›
                if(result.size() == k) break;
            }
        }

        return result;
    }
};

```

### åŠå¿«æ’ç­–ç•¥

```c++
class Solution {
public:
    vector<int> result;

    // å¿«é€Ÿé€‰æ‹©ï¼šå¯»æ‰¾å‰ k å¤§çš„é¢‘ç‡å…ƒç´ 
    void qsort(vector<pair<int, int>>& arr, int left, int right, int k) {
        pair<int, int> pivot = arr[left]; // é€‰å–å·¦ä¾§ä½œä¸ºåŸºå‡†
        int i = left;
        int j = right;

        // åˆ†åŒºè¿‡ç¨‹ï¼šå¤§äº pivot çš„æ”¾å·¦è¾¹ï¼Œå°äº pivot çš„æ”¾å³è¾¹
        while (i < j) {
            while (i < j && arr[j].second <= pivot.second) {
                j--;
            }
            while (i < j && arr[i].second >= pivot.second) {
                i++;
            }
            swap(arr[i], arr[j]);
        }
        swap(arr[left], arr[i]); // å°†åŸºå‡†æ”¾åˆ°æœ€ç»ˆä½ç½®

        if (i == k - 1) { // æ‰¾åˆ°å‰ k å¤§é¢‘ç‡ä½ç½®
            for (int idx = 0; idx < k; idx++) {
                result.push_back(arr[idx].first);
            }
        }
        else if (i < k - 1) { // ç»§ç»­åœ¨å³åŠéƒ¨åˆ†æ‰¾
            qsort(arr, i + 1, right, k);
        }
        else { // ç»§ç»­åœ¨å·¦åŠéƒ¨åˆ†æ‰¾
            qsort(arr, left, i - 1, k);
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq_map;
        for (int num : nums) {
            freq_map[num]++;
        }

        // å°†å“ˆå¸Œè¡¨è½¬æ¢ä¸º (num, freq) å¯¹
        vector<pair<int, int>> arr;
        for (auto& [num, freq] : freq_map) {
            arr.emplace_back(num, freq);
        }

        // å¿«é€Ÿé€‰æ‹©å‰ k å¤§é¢‘ç‡
        qsort(arr, 0, arr.size() - 1, k);

        return result;
    }
};

```

## Key point



### priority_queueè‡ªå®šä¹‰æ’åº

åœ¨ C++ ä¸­ï¼Œ`<priority_queue>` æ˜¯æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºå®ç°ä¼˜å…ˆé˜Ÿåˆ—ã€‚

ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ç§ç‰¹æ®Šçš„é˜Ÿåˆ—ï¼Œå®ƒå…è®¸æˆ‘ä»¬å¿«é€Ÿè®¿é—®é˜Ÿåˆ—ä¸­å…·æœ‰æœ€é«˜ï¼ˆæˆ–æœ€ä½ï¼‰ä¼˜å…ˆçº§çš„å…ƒç´ ã€‚

åœ¨ C++ ä¸­ï¼Œ`priority_queue` é»˜è®¤æ˜¯ä¸€ä¸ªæœ€å¤§å †ï¼Œè¿™æ„å‘³ç€é˜Ÿåˆ—çš„é¡¶éƒ¨å…ƒç´ æ€»æ˜¯å…·æœ‰æœ€å¤§çš„å€¼ã€‚

`priority_queue` æ˜¯ä¸€ä¸ªå®¹å™¨é€‚é…å™¨ï¼Œå®ƒæä¾›äº†å¯¹åº•å±‚å®¹å™¨çš„å †æ“ä½œã€‚å®ƒä¸æä¾›è¿­ä»£å™¨ï¼Œä¹Ÿä¸æ”¯æŒéšæœºè®¿é—®ã€‚

```c++
#include <queue>

// å£°æ˜ä¸€ä¸ªæ•´å‹ä¼˜å…ˆé˜Ÿåˆ—
priority_queue<int> pq;

// å£°æ˜ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œéœ€è¦æä¾›æ¯”è¾ƒå‡½æ•°
struct compare {
    bool operator()(int a, int b) {
        return a > b; // è¿™é‡Œå®šä¹‰äº†æœ€å°å †
    }
};
priority_queue<int, vector<int>, compare> pq_min;
```

```c++
bool cmp(vector<int>&a,vector<int>&b){
	return a[0]>b[0];
}
priority_queue<vector<int>,vector<vector<int>>,decltype(&cmp)> pq(cmp); //æ³¨æ„é˜Ÿåˆ—pqè¿˜è¦ä¼ å…¥cmp

```



### ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥ç”¨æ™®é€šå‡½æ•°æˆ–è€…é™æ€å‡½æ•°æ¥ä½œä¸ºæ¯”è¾ƒå™¨

â€‹	å› ä¸º`priority_queue` éœ€è¦ä¸€ä¸ª**ç±»å‹**ä½œä¸ºæ¨¡æ¿å‚æ•°ï¼Œç”¨æ¥æ„é€ æ¯”è¾ƒå™¨å¯¹è±¡ï¼Œè€Œä¸èƒ½æ˜¯ä¸€ä¸ªæ™®é€šå‡½æ•°æŒ‡é’ˆã€‚

```cpp
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œ`priority_queue` æœŸæœ›çš„æ˜¯ä¸€ä¸ª**ç±»å‹** `Compare`ï¼Œç„¶ååœ¨å†…éƒ¨ç”¨å®ƒæ¥åˆ›å»ºå¯¹è±¡ï¼š

```cpp
Compare comp;
if (comp(a, b)) { ... }
```

è€Œå†™çš„è¿™ä¸ªï¼š

```cpp
static bool cmp(ListNode* a, ListNode* b) {
    return a->val < b->val;
}
```

å®ƒæ˜¯ä¸€ä¸ª**å‡½æ•°**ï¼Œä¸æ˜¯ç±»å‹ï¼Œæ²¡æ³•ä¼ å…¥ `priority_queue` æ¨¡æ¿å‚æ•°ä¸­ã€‚

### ç›¸å…³å†…å®¹

å®šä¹‰
`priority_queue<Type, Container, Functional>;`

* Typeæ˜¯è¦å­˜æ”¾çš„æ•°æ®ç±»å‹
* Containeræ˜¯å®ç°åº•å±‚å †çš„å®¹å™¨ï¼Œå¿…é¡»æ˜¯æ•°ç»„å®ç°çš„å®¹å™¨ï¼Œå¦‚vectorã€deque
* Functionalæ˜¯æ¯”è¾ƒæ–¹å¼/æ¯”è¾ƒå‡½æ•°/ä¼˜å…ˆçº§

`priority_queue<Type>;`

æ­¤æ—¶é»˜è®¤çš„å®¹å™¨æ˜¯vectorï¼Œé»˜è®¤çš„æ¯”è¾ƒæ–¹å¼æ˜¯å¤§é¡¶å †less<type>

ä¸¾ä¾‹

```c++
//å°é¡¶å †
priority_queue <int,vector<int>,greater<int> > q;
//å¤§é¡¶å †
priority_queue <int,vector<int>,less<int> >q;
//é»˜è®¤å¤§é¡¶å †
priority_queue<int> a;
//pair
priority_queue<pair<int, int> > a;
pair<int, int> b(1, 2);
pair<int, int> c(1, 3);
pair<int, int> d(2, 5);
a.push(d);
a.push(c);
a.push(b);
while (!a.empty()) 
{
   cout << a.top().first << ' ' << a.top().second << '\n';
   a.pop();
}
//è¾“å‡ºç»“æœä¸ºï¼š
2 5
1 3
1 2
```


å¸¸ç”¨å‡½æ•°

```c++
top()

pop()

push()

emplace()

empty()

size()
```

è‡ªå®šä¹‰æ¯”è¾ƒæ–¹å¼
å½“æ•°æ®ç±»å‹å¹¶ä¸æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œè€Œæ˜¯è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹æ—¶ï¼Œå°±ä¸èƒ½ç”¨greateræˆ–lessçš„æ¯”è¾ƒæ–¹å¼äº†ï¼Œè€Œæ˜¯éœ€è¦è‡ªå®šä¹‰æ¯”è¾ƒæ–¹å¼

åœ¨æ­¤å‡è®¾æ•°æ®ç±»å‹æ˜¯è‡ªå®šä¹‰çš„æ°´æœï¼š

```c++
struct fruit
{
	string name;
	int price;
};
```


æœ‰ä¸¤ç§è‡ªå®šä¹‰æ¯”è¾ƒæ–¹å¼çš„æ–¹æ³•ï¼Œå¦‚ä¸‹

1. é‡è½½è¿ç®—ç¬¦
   é‡è½½â€<â€

è‹¥å¸Œæœ›æ°´æœä»·æ ¼é«˜ä¸ºä¼˜å…ˆçº§é«˜ï¼Œåˆ™

```c++
//å¤§é¡¶å †
struct fruit
{
	string name;
	int price;
	friend bool operator < (fruit f1,fruit f2)
	{
		return f1.peice < f2.price;
	}
};
```


è‹¥å¸Œæœ›æ°´æœä»·æ ¼ä½ä¸ºä¼˜å…ˆçº§é«˜

```c++
//å°é¡¶å †
struct fruit
{
	string name;
	int price;
	friend bool operator < (fruit f1,fruit f2)
	{
		return f1.peice > f2.price;  //æ­¤å¤„æ˜¯>
	}
};
```

2.ä»¿å‡½æ•°
è‹¥å¸Œæœ›æ°´æœä»·æ ¼é«˜ä¸ºä¼˜å…ˆçº§é«˜ï¼Œåˆ™

```c++
//å¤§é¡¶å †
struct myComparison
{
	bool operator () (fruit f1,fruit f2)
	{
		return f1.price < f2.price;
	}
};
//æ­¤æ—¶ä¼˜å…ˆé˜Ÿåˆ—çš„å®šä¹‰åº”è¯¥å¦‚ä¸‹
priority_queue<fruit,vector<fruit>,myComparison> q;
```

