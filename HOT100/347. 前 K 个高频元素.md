# [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序**  返回答案。

**示例 1:** 

```
**输入: ** nums = [1,1,1,2,2,3], k = 2
**输出: ** [1,2]
```

**示例 2:** 

```
**输入: ** nums = [1], k = 1
**输出: ** [1]```

**提示：** 

- `1 <= nums.length <= 10^5`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：** 你所设计算法的时间复杂度 **必须**  优于 `O(n log n)` ，其中 `n`是数组大小。
```

## Solutions

1. priority_queue + 小根堆策略
2. priority_queue + 大根堆策略
3. 手动实现小根堆
4. 桶排序策略
5. 半快排策略

## Code

### priority_queue + 小根堆策略

官方写法：

```c++
class Solution {
public:
    // 比较函数，用于 priority_queue 构建小根堆（堆顶是频率最小的元素）
    struct cmp {
        bool operator()(pair<int, int>& a, pair<int, int>& b) {
            return a.second > b.second; 
            // 返回 true 表示 b 优先级高于 a，因此会将 second 小的放在堆顶
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计每个元素出现的频率
        unordered_map<int, int> record;
        for (int num : nums) {
            record[num]++;
        }

        // 小根堆，容量固定为 k
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq;

        for (auto [num, count] : record) {
            if (pq.size() < k) {
                // 堆未满，直接插入
                pq.push({num, count});
            } else {
                // 堆已满
                if (pq.top().second < count) {
                    // 若当前元素频率大于堆顶（最小频率），则弹出堆顶并插入当前元素
                    pq.pop();
                    pq.push({num, count});
                }
                // 若当前元素频率 <= 堆顶，不做任何操作
            }
        }

        // 从堆中依次取出元素，收集结果
        vector<int> result;
        while (!pq.empty()) {
            result.push_back(pq.top().first); // 只取元素值
            pq.pop();
        }

        // 如果题目需要从高到低返回，可在此反转结果
        // reverse(result.begin(), result.end());

        return result;
    }
};

```

### priority_queue + 小根堆策略

```c++
class Solution {
public:
    // 比较函数，用于 priority_queue 构建大根堆（堆顶是频率最大的元素）
    struct cmp {
        bool operator()(pair<int, int>& a, pair<int, int>& b) {
            return a.second < b.second; // 大根堆：频率大的优先级高
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> record;
        // 统计每个元素出现的频率
        for (int num : nums) {
            record[num]++;
        }

        // 大根堆，存储 <num, count>，按 count 从大到小排序
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pq;
        for (auto [num, count] : record) {
            pq.push({num, count});
        }

        vector<int> result;
        int i = 0;
        // 取出堆顶前 k 个元素，即频率最高的 k 个元素
        while (!pq.empty() && i < k) {
            i++;
            result.push_back(pq.top().first); // 只保存元素
            pq.pop();
        }
        return result;
    }
};

```

### 手动实现小根堆

```c++
class Solution {
public:
    vector<pair<int, int>> pq; // 小根堆，维护 size = k

    void insert_pq(int num, int count, int k) {
        if (pq.size() < k) {
            // 堆未满，直接插入并向上调整
            pq.emplace_back(num, count);//这种插入无需创建新的对象
            int idx = pq.size() - 1;
            while (idx > 0) {
                int parent = (idx - 1) / 2;
                if (pq[parent].second > pq[idx].second) {
                    swap(pq[parent], pq[idx]);
                    idx = parent;
                } else {
                    break;
                }
            }
        } else {
            // 堆已满，判断是否需要替换堆顶
            if (pq[0].second < count) {
                pq[0] = {num, count}; // 替换堆顶
                // 向下调整
                int idx = 0;
                int n = pq.size();
                while (true) {
                    int left = 2 * idx + 1;
                    int right = 2 * idx + 2;
                    int smallest = idx;
                    if (left < n && pq[left].second < pq[smallest].second) {
                        smallest = left;
                    }
                    if (right < n && pq[right].second < pq[smallest].second) {
                        smallest = right;
                    }
                    if (smallest != idx) {
                        swap(pq[idx], pq[smallest]);
                        idx = smallest;
                    } else {
                        break;
                    }
                }
            }
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        pq.clear(); // 🚩 修复多组测试时未清空的问题

        unordered_map<int, int> freq_map;
        for (int num : nums) {
            freq_map[num]++;
        }

        for (const auto& [num, count] : freq_map) {
            insert_pq(num, count, k);
        }

        vector<int> result;
        for (const auto& p : pq) {
            result.push_back(p.first);
        }

        // 如果需要返回按频率从高到低排序，可启用以下排序
        // sort(result.begin(), result.end(), [&](int a, int b) {
        //     return freq_map[a] > freq_map[b];
        // });

        return result;
    }
};

```

### 桶排序策略

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();

        // 创建 n+1 个桶，桶下标表示出现次数
        // buckets[f] 中存储所有出现次数为 f 的元素
        vector<vector<int>> buckets(n + 1);

        // 统计每个元素出现的次数
        unordered_map<int, int> freq_map;
        for(int num : nums){
            freq_map[num]++;
        }

        // 根据出现次数将元素放入对应桶中
        for(auto& [num, freq] : freq_map){
            buckets[freq].push_back(num);
        }

        vector<int> result;
        // 从出现次数最多 (n) 的桶开始遍历，向下找出现次数较少的桶
        for(int freq = n; freq >= 0 && result.size() < k; freq--){
            // 遍历当前桶中的每个元素
            for(int num : buckets[freq]){
                result.push_back(num);
                // 找到 k 个后立即返回
                if(result.size() == k) break;
            }
        }

        return result;
    }
};

```

### 半快排策略

```c++
class Solution {
public:
    vector<int> result;

    // 快速选择：寻找前 k 大的频率元素
    void qsort(vector<pair<int, int>>& arr, int left, int right, int k) {
        pair<int, int> pivot = arr[left]; // 选取左侧作为基准
        int i = left;
        int j = right;

        // 分区过程：大于 pivot 的放左边，小于 pivot 的放右边
        while (i < j) {
            while (i < j && arr[j].second <= pivot.second) {
                j--;
            }
            while (i < j && arr[i].second >= pivot.second) {
                i++;
            }
            swap(arr[i], arr[j]);
        }
        swap(arr[left], arr[i]); // 将基准放到最终位置

        if (i == k - 1) { // 找到前 k 大频率位置
            for (int idx = 0; idx < k; idx++) {
                result.push_back(arr[idx].first);
            }
        }
        else if (i < k - 1) { // 继续在右半部分找
            qsort(arr, i + 1, right, k);
        }
        else { // 继续在左半部分找
            qsort(arr, left, i - 1, k);
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq_map;
        for (int num : nums) {
            freq_map[num]++;
        }

        // 将哈希表转换为 (num, freq) 对
        vector<pair<int, int>> arr;
        for (auto& [num, freq] : freq_map) {
            arr.emplace_back(num, freq);
        }

        // 快速选择前 k 大频率
        qsort(arr, 0, arr.size() - 1, k);

        return result;
    }
};

```

## Key point



### priority_queue自定义排序

在 C++ 中，`<priority_queue>` 是标准模板库（STL）的一部分，用于实现优先队列。

优先队列是一种特殊的队列，它允许我们快速访问队列中具有最高（或最低）优先级的元素。

在 C++ 中，`priority_queue` 默认是一个最大堆，这意味着队列的顶部元素总是具有最大的值。

`priority_queue` 是一个容器适配器，它提供了对底层容器的堆操作。它不提供迭代器，也不支持随机访问。

```c++
#include <queue>

// 声明一个整型优先队列
priority_queue<int> pq;

// 声明一个自定义类型的优先队列，需要提供比较函数
struct compare {
    bool operator()(int a, int b) {
        return a > b; // 这里定义了最小堆
    }
};
priority_queue<int, vector<int>, compare> pq_min;
```

```c++
bool cmp(vector<int>&a,vector<int>&b){
	return a[0]>b[0];
}
priority_queue<vector<int>,vector<vector<int>>,decltype(&cmp)> pq(cmp); //注意队列pq还要传入cmp

```



### 为什么不能直接用普通函数或者静态函数来作为比较器

​	因为`priority_queue` 需要一个**类型**作为模板参数，用来构造比较器对象，而不能是一个普通函数指针。

```cpp
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```

也就是说，`priority_queue` 期望的是一个**类型** `Compare`，然后在内部用它来创建对象：

```cpp
Compare comp;
if (comp(a, b)) { ... }
```

而写的这个：

```cpp
static bool cmp(ListNode* a, ListNode* b) {
    return a->val < b->val;
}
```

它是一个**函数**，不是类型，没法传入 `priority_queue` 模板参数中。

### 相关内容

定义
`priority_queue<Type, Container, Functional>;`

* Type是要存放的数据类型
* Container是实现底层堆的容器，必须是数组实现的容器，如vector、deque
* Functional是比较方式/比较函数/优先级

`priority_queue<Type>;`

此时默认的容器是vector，默认的比较方式是大顶堆less<type>

举例

```c++
//小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//大顶堆
priority_queue <int,vector<int>,less<int> >q;
//默认大顶堆
priority_queue<int> a;
//pair
priority_queue<pair<int, int> > a;
pair<int, int> b(1, 2);
pair<int, int> c(1, 3);
pair<int, int> d(2, 5);
a.push(d);
a.push(c);
a.push(b);
while (!a.empty()) 
{
   cout << a.top().first << ' ' << a.top().second << '\n';
   a.pop();
}
//输出结果为：
2 5
1 3
1 2
```


常用函数

```c++
top()

pop()

push()

emplace()

empty()

size()
```

自定义比较方式
当数据类型并不是基本数据类型，而是自定义的数据类型时，就不能用greater或less的比较方式了，而是需要自定义比较方式

在此假设数据类型是自定义的水果：

```c++
struct fruit
{
	string name;
	int price;
};
```


有两种自定义比较方式的方法，如下

1. 重载运算符
   重载”<”

若希望水果价格高为优先级高，则

```c++
//大顶堆
struct fruit
{
	string name;
	int price;
	friend bool operator < (fruit f1,fruit f2)
	{
		return f1.peice < f2.price;
	}
};
```


若希望水果价格低为优先级高

```c++
//小顶堆
struct fruit
{
	string name;
	int price;
	friend bool operator < (fruit f1,fruit f2)
	{
		return f1.peice > f2.price;  //此处是>
	}
};
```

2.仿函数
若希望水果价格高为优先级高，则

```c++
//大顶堆
struct myComparison
{
	bool operator () (fruit f1,fruit f2)
	{
		return f1.price < f2.price;
	}
};
//此时优先队列的定义应该如下
priority_queue<fruit,vector<fruit>,myComparison> q;
```

