# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：** 

```
**输入：** intervals = [[1,3],[2,6],[8,10],[15,18]]
**输出：** [[1,6],[8,10],[15,18]]
**解释：** 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例2：** 

```
**输入：** intervals = [[1,4],[4,5]]
**输出：** [[1,5]]
**解释：** 区间 [1,4] 和 [4,5] 可被视为重叠区间。```

**提示：** 

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^4`
```

## Solution

合并区间：排序+双指针

## Code

```c++
class Solution {
public:
    // 自定义排序函数：按照每个区间的起始位置升序排列
    static bool cmp(vector<int>& a, vector<int>& b){
        return a[0] < b[0];
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 先按照区间起点进行排序，确保后续合并顺序正确
        sort(intervals.begin(), intervals.end(), cmp);

        vector<vector<int>> res;  // 存储合并后的结果区间
        int start = 0;            // 当前合并区间的起始点
        int end = -1;             // 当前合并区间的终止点，初始化为 -1 表示尚未开始合并

        for (int i = 0; i < intervals.size(); i++) {
            int front = intervals[i][0];  // 当前区间起点
            int back = intervals[i][1];   // 当前区间终点

            if (end < front) {
                // 当前区间与已合并区间无重叠（即：不连续），则保存前一个合并区间
                if (end != -1) {
                    res.push_back({start, end});
                }
                // 启动新的合并区间
                start = front;
                end = back;
            } else {
                // 当前区间与之前区间重叠或连续，更新合并终点
                end = max(end, back);
            }
        }

        // 最后一次合并的区间未被加入结果，补上
        if (end != -1) {
            res.push_back({start, end});
        }

        return res;
    }
};

```

