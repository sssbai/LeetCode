# [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组`nums`，返回 数组`answer`，其中`answer[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积。

题目数据 **保证**  数组`nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位**  整数范围内。

请**不要使用除法，** 且在`O(n)` 时间复杂度内完成此题。

**示例 1:** 

```
**输入:**  nums = `[1,2,3,4]`
**输出:**  `[24,12,8,6]`
```

**示例 2:** 

```
**输入:**  nums = [-1,1,0,-3,3]
**输出:**  [0,0,9,0,0]
```

**提示：** 

- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- 输入**保证**  数组`answer[i]`在 **32 位**  整数范围内

**进阶：** 你可以在 `O(1)`的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为** 额外空间。）

## Solution

前缀乘积+后缀乘积

## Code

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();

        // arr1[i] 存储 nums[0] 到 nums[i] 的前缀乘积
        vector<int> arr1(n, 1);
        for (int i = 0; i < n; i++) {
            if (i == 0) arr1[i] = nums[i];
            else arr1[i] = nums[i] * arr1[i - 1];
        }

        // arr2[i] 存储 nums[i] 到 nums[n - 1] 的后缀乘积
        vector<int> arr2(n, 1);
        for (int i = n - 1; i >= 0; i--) {
            if (i == n - 1) arr2[i] = nums[i];
            else arr2[i] = nums[i] * arr2[i + 1];
        }

        // 结果数组 res[i] = 左边乘积 * 右边乘积
        vector<int> res(n, 1);
        for (int i = 0; i < n; i++) {
            if (i == 0) res[i] = arr2[i + 1];          // 没有左边元素
            else if (i == n - 1) res[i] = arr1[i - 1]; // 没有右边元素
            else res[i] = arr1[i - 1] * arr2[i + 1];   // 左右都乘
        }

        return res;
    }
};

```

