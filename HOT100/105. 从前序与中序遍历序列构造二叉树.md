# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

给定两个整数数组`preorder` 和 `inorder`，其中`preorder` 是二叉树的**先序遍历** ， `inorder`是同一棵树的**中序遍历** ，请构造二叉树并返回其根节点。

**示例 1:** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508061606000.jpg" style="height: 302px; width: 277px;">

```
**输入** **:**  preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
**输出:**  [3,9,20,null,null,15,7]
```

**示例 2:** 

```
**输入:**  preorder = [-1], inorder = [-1]
**输出:**  [-1]
```

**提示:** 

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder`和`inorder`均 **无重复**  元素
- `inorder`均出现在`preorder`
- `preorder`**保证**  为二叉树的前序遍历序列
- `inorder`**保证**  为二叉树的中序遍历序列

## Solution

前序+中序-》构建二叉树，dfs+哈希

## Code

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    unordered_map<int, int> res; // 用于快速查找中序遍历中每个值的下标

    /**
     * 递归构建子树
     * @param preorder 先序遍历数组
     * @param inorder 中序遍历数组
     * @param pre_l 当前子树在 preorder 中的左边界
     * @param pre_r 当前子树在 preorder 中的右边界
     * @param in_l 当前子树在 inorder 中的左边界
     * @param in_r 当前子树在 inorder 中的右边界
     * @return 构建好的子树的根节点
     */
    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int pre_l, int pre_r, int in_l, int in_r) {
        // 如果子树区间非法，返回空指针
        if (pre_l > pre_r) return nullptr;

        // 获取当前子树的根节点值（先序遍历的第一个值）
        int root_val = preorder[pre_l];

        // 在中序遍历中查找该值的下标
        int mid = res[root_val];

        // 创建当前子树的根节点
        TreeNode* node = new TreeNode(root_val);

        // 计算左子树节点个数：mid - in_l
        int left_size = mid - in_l;

        // 构建左子树（对应 preorder 中的位置是 root 后面 left_size 个节点）
        node->left = dfs(preorder, inorder, pre_l + 1, pre_l + left_size, in_l, mid - 1);

        // 构建右子树（剩余部分）
        node->right = dfs(preorder, inorder, pre_l + left_size + 1, pre_r, mid + 1, in_r);

        return node;
    }

    /**
     * 主函数，构建整棵树
     */
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();

        // 将中序遍历的值映射到对应的下标，便于查找
        for (int i = 0; i < n; i++) {
            res[inorder[i]] = i;
        }

        // 调用递归函数构建整棵树
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};

```

