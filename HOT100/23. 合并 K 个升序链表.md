# [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：** 

```
**输入：** lists = [[1,4,5],[1,3,4],[2,6]]
**输出：** [1,1,2,3,4,4,5,6]
**解释：** 链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：** 

```
**输入：** lists = []
**输出：** []
```

**示例 3：** 

```
**输入：** lists = [[]]
**输出：** []
```

**提示：** 

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序**  排列
- `lists[i].length` 的总和不超过 `10^4`

## Solution

归并排序

小根堆

## Code

### 归并排序

```c++
/**
 * Definition for singly-linked list.
 */
struct ListNode {
    int val;                // 节点值
    ListNode *next;         // 指向下一个节点的指针
    ListNode() : val(0), next(nullptr) {}                          // 默认构造函数
    ListNode(int x) : val(x), next(nullptr) {}                     // 只初始化值的构造函数
    ListNode(int x, ListNode *next) : val(x), next(next) {}        // 初始化值和指针的构造函数
};

class Solution {
public:
    // 分治递归合并区间 [left, right] 内的链表
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 当区间只有一个链表时，直接返回该链表
        if (left == right) return lists[left];
        // 当区间无效时，返回空指针
        else if (left > right) return nullptr;

        // 取中点，分成两部分继续递归合并
        int mid = left + (right - left) / 2;
        ListNode* lnode = merge(lists, left, mid);        // 左半部分合并结果
        ListNode* rnode = merge(lists, mid + 1, right);   // 右半部分合并结果

        // 新建哑节点，方便合并链表
        ListNode* dummy = new ListNode();
        ListNode* cur = dummy;

        // 合并两个有序链表 lnode 和 rnode
        while (lnode && rnode) {
            if (lnode->val < rnode->val) {
                cur->next = lnode;      // lnode 当前节点更小，接入合并链表
                lnode = lnode->next;    // lnode 指针后移
            } else {
                cur->next = rnode;      // rnode 当前节点更小或相等，接入合并链表
                rnode = rnode->next;    // rnode 指针后移
            }
            cur = cur->next;            // 合并链表指针后移
        }

        // 处理剩余未遍历完的链表
        if (lnode) cur->next = lnode;
        else cur->next = rnode;

        return dummy->next;  // 返回合并后链表的头节点（跳过哑节点）
    }

    // 主函数，合并所有链表
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);  // 调用递归合并函数，传入区间左右边界
    }
};

```

