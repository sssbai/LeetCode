# [207. 课程表](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)

你这个学期必须选修 `numCourses` 门课程，记为`0`到`numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组`prerequisites` 给出，其中`prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]` ，表示如果要学习课程`a<sub>i</sub>` 则 **必须**  先学习课程 `b<sub>i</sub>`<sub> </sub>。

- 例如，先修课程对`[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：** 

```
**输入：** numCourses = 2, prerequisites = [[1,0]]
**输出：** true
**解释：** 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。```

**示例 2：** 

```
**输入：** numCourses = 2, prerequisites = [[1,0],[0,1]]
**输出：** false
**解释：** 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。```

**提示：** 

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

## Solution





## Code

### DFS判断是否有环

```c++
class Solution {
public:
    // records[i] 存储课程 i 的所有前置课程（邻接表形式）
    vector<vector<int>> records;

    // mem[i] 的状态：0 = 未访问，1 = 正在访问（路径上），2 = 已完成访问（无环）
    vector<int> mem;

    // DFS 判断以课程 i 为起点是否存在环
    bool dfs(int i){
        if (mem[i] == 2) return true;     // 已经访问完成，无需再次访问，说明没有环
        else if (mem[i] == 1) return false; // 再次访问到“正在访问”的节点，说明图中有环
        else {
            bool tag = true;
            mem[i] = 1;  // 标记为“正在访问”

            // 遍历当前课程的所有前置课程，递归判断是否存在环
            for (int j = 0; j < records[i].size(); j++) {
                tag = tag && dfs(records[i][j]); // 一旦某个依赖存在环，tag 变为 false
            }

            mem[i] = 2;  // 访问完成，标记为“无环”
            return tag;
        }
    }

    // 判断是否能完成所有课程，即图中是否存在环
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 初始化邻接表和状态数组
        records.resize(numCourses);
        mem.resize(numCourses, 0); // 初始状态为 0（未访问）

        // 构建邻接表，记录每门课程的前置课程
        for (auto value : prerequisites) {
            records[value[0]].push_back(value[1]);
        }

        bool tag = true;

        // 对每个课程进行 DFS 检查是否有环
        for (int i = 0; i < numCourses; i++) {
            tag = tag && dfs(i);
        }

        return tag; // 如果所有课程都无环，返回 true；否则返回 false
    }
};

```



### 拓扑排序（BFS）

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 入度数组：每门课有多少个前置课没完成
        vector<int> inDegree(numCourses, 0);

        // 邻接表：记录每门课后面依赖它的课程（即它是这些课的前置课）
        vector<vector<int>> graph(numCourses);

        // 构建图和入度数组
        for (auto& pair : prerequisites) {
            int course = pair[0];
            int pre = pair[1];
            inDegree[course]++;         // 课程 course 的前置课数量 +1
            graph[pre].push_back(course); // 完成 pre 课程可以解锁 course 课程
        }

        // 将所有入度为0的课程加入队列（即没有前置要求的课程）
        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }

        // 记录已经学完的课程数量
        int coursesCompleted = 0;

        // 拓扑排序，逐个学习可以学习的课程
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            coursesCompleted++;

            // 遍历所有被当前课程解锁的课程
            for (int nextCourse : graph[current]) {
                inDegree[nextCourse]--;  // 减去一个前置课程
                if (inDegree[nextCourse] == 0) {
                    q.push(nextCourse); // 如果前置课程都学完了，可以学这门课
                }
            }
        }

        // 如果完成课程数等于总课程数，说明可以完成所有课程
        return coursesCompleted == numCourses;
    }
};

```

