# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:** 

<img src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507111559585.jpg">

```
**输入：** heights = [2,1,5,6,2,3]
**输出：** 10
**解释：** 最大的矩形为图中红色区域，面积为 10
```

**示例 2：** 

<img src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507111559611.jpg">

```
**输入：**  heights = [2,4]
<b>输出：</b> 4```

**提示：** 

- `1 <= heights.length <=10^5`
- `0 <= heights[i] <= 10^4`
```

## Solution

这道题属于单调栈的问题

1. 最大柱状面积一定是基于某个柱状图 $j$ 的高度获得的，因此只要找到左侧小余其高度的柱体位置 $left$，找到右侧小余其高度的柱体位置 $right$。计算 $height[i]\times(right-left-1)$。
2. $left$ 和 $right$ 是通过单调栈来计算。
3. 需要注意的点是，$left$ 的初始值为 -1，$right$ 的初始值为 n。

## Code

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> left(n, -1);
        vector<int> right(n, n);
        stack<int> st1;
        for (int i = 0; i < n; i++) {
            while(!st1.empty() && heights[i]<heights[st1.top()]){
                right[st1.top()] = i;
                st1.pop();
            }
            st1.push(i);
        }
        stack<int> st2;
        for (int i = n - 1; i >= 0; i--) {
            while(!st2.empty() && heights[i]<heights[st2.top()]){
                left[st2.top()] = i;
                st2.pop();
            }
            st2.push(i);
        }
        int maxArea = 0;
        for(int i = 0; i < n; i++){
            maxArea = max(maxArea, heights[i] * (right[i] - left[i] - 1));
        }
        return maxArea;
    }
};
```



