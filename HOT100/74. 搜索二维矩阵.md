# [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508051041183.jpg" style="width: 322px; height: 242px;">

```
**输入：** matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
**输出：** true
```

**示例 2：** 
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" style="width: 322px; height: 242px;">

```
**输入：** matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
**输出：** false
```

**提示：** 

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-10^4 <= matrix[i][j], target <= 10^4`

## Solution

二维二分查找的方法，时间复杂度$O(m+n)$

## Code

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();          // 获取矩阵的行数
        int m = matrix[0].size();       // 获取矩阵的列数

        int i = 0;                      // 从矩阵的右上角开始搜索（第 0 行）
        int j = m - 1;                  // 从最后一列开始（第 m-1 列）

        // 循环条件：没有越界
        while (i < n && j >= 0) {
            if (target < matrix[i][j]) {
                // 目标值比当前值小，说明目标在当前行更左边 → 向左移动
                j--;
            }
            else if (target > matrix[i][j]) {
                // 目标值比当前值大，说明目标在当前列更下方 → 向下移动
                i++;
            }
            else {
                // 找到了目标值，返回 true
                return true;
            }
        }

        // 遍历完也没有找到目标值，返回 false
        return false;
    }
};

```

