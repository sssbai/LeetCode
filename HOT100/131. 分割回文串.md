# [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s`，请你将 `s` 分割成一些 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子串</button>，使每个子串都是 **<button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">回文串</button>**  。返回 `s` 所有可能的分割方案。

**示例 1：** 

```
**输入：** s = "aab"
**输出：** [["a","a","b"],["aa","b"]]
```

**示例 2：** 

```
**输入：** s = "a"
**输出：** [["a"]]
```

**提示：** 

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

## Solution

回溯

## Code

```c++
class Solution {
public:
    vector<vector<string>> res; // 最终的结果集

    // 深度优先搜索 + 回溯
    void dfs(string s, int i, vector<string> path) {
        if (i >= s.size()) {
            res.push_back(path); // 到达末尾，收集当前合法路径
            return;
        }

        // 尝试从位置 i 到 j 的所有子串
        for (int j = i; j < s.size(); j++) {
            string a = s.substr(i, j - i + 1); // 取出子串 s[i..j]
            string b = a;
            reverse(b.begin(), b.end()); // 反转后判断是否为回文串

            if (a == b) {
                path.push_back(a);         // 如果是回文，加入路径
                dfs(s, j + 1, path);       // 继续从下一个位置递归
                path.pop_back();           // 回溯，移除最后一个子串
            }
        }
    }

    vector<vector<string>> partition(string s) {
        dfs(s, 0, {}); // 从下标 0 开始 DFS
        return res;
    }
};

```

