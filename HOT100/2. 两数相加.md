# [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)

给你两个**非空**  的链表，表示两个非负的整数。它们每位数字都是按照**逆序** 的方式存储的，并且每个节点只能存储**一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0开头。

<strong class="example">示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508051926262.jpg" style="width: 483px; height: 342px;">

```
**输入：** l1 = [2,4,3], l2 = [5,6,4]
**输出：** [7,0,8]
**解释：** 342 + 465 = 807.
```

<strong class="example">示例 2：** 

```
**输入：** l1 = [0], l2 = [0]
**输出：** [0]
```

<strong class="example">示例 3：** 

```
**输入：** l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
**输出：** [8,9,9,9,0,0,0,1]
```

**提示：** 

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

## Solution



## Code

```c++
/**
 * Definition for singly-linked list.
 * 表示单链表的节点结构
 */
struct ListNode {
    int val;              // 节点的值
    ListNode *next;       // 指向下一个节点的指针
    ListNode() : val(0), next(nullptr) {}                     // 默认构造函数
    ListNode(int x) : val(x), next(nullptr) {}               // 构造函数，带初始值
    ListNode(int x, ListNode *next) : val(x), next(next) {}  // 构造函数，带初始值和指针
};

class Solution {
public:
    // 主函数：将两个链表代表的数字相加，返回一个新的链表
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(); // 创建哑节点，方便处理头结点逻辑
        ListNode* cur = dummy;            // 当前处理的节点指针
        int n = 0;                         // n 用来记录每一位的和以及进位

        // 同时遍历 l1 和 l2
        while (l1 && l2) {
            n = l1->val + l2->val + n;          // 当前位的加法 + 上一次进位
            l1 = l1->next;                      // 移动 l1 指针
            l2 = l2->next;                      // 移动 l2 指针
            cur->next = new ListNode(n % 10);   // 创建新节点保存个位数字
            cur = cur->next;                    // 移动 cur 指针
            n /= 10;                            // 保留进位（0 或 1）
        }

        // 如果 l1 还有剩余
        while (l1) {
            n = l1->val + n;                    // 加上进位
            l1 = l1->next;
            cur->next = new ListNode(n % 10);   // 保存个位数
            cur = cur->next;
            n /= 10;                            // 更新进位
        }

        // 如果 l2 还有剩余
        while (l2) {
            n = l2->val + n;
            l2 = l2->next;
            cur->next = new ListNode(n % 10);
            cur = cur->next;
            n /= 10;
        }

        // 如果最后还有进位
        if (n) {
            cur->next = new ListNode(n % 10);
        }

        return dummy->next; // 返回头结点的下一个，即实际结果链表的头
    }
};

```

