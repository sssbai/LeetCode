# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉树的 **根节点**  `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<strong class="example">示例 1：** 

<div class="example-block">
<b>输入：</b>root = [1,2,3,null,5,null,4]

**输出：** [1,3,4]

**解释：** 

<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508051643401.png" style="width: 400px; height: 207px;">

<strong class="example">示例 2：** 

<div class="example-block">
<b>输入：</b>root = [1,2,3,4,null,null,null,5]

<b>输出：</b>[1,3,4,5]

**解释：** 

<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508051643633.png" style="width: 400px; height: 214px;">

<strong class="example">示例 3：** 

<div class="example-block">
**输入：** root = [1,null,3]

**输出：** [1,3]

<strong class="example">示例 4：** 

<div class="example-block">
<b>输入：</b>root = []

**输出：** []

**提示:** 

- 二叉树的节点个数的范围是 `[0,100]`
- `-100<= Node.val <= 100`

## Solution

BFS

## Code

```c++
/**
 * Definition for a binary tree node.
 * 二叉树节点结构定义
 */
struct TreeNode {
    int val;                // 节点值
    TreeNode *left;         // 左子节点指针
    TreeNode *right;        // 右子节点指针
    TreeNode() : val(0), left(nullptr), right(nullptr) {}  // 默认构造
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  // 指定值构造
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;   // 用于层序遍历的队列
        vector<int> res;        // 存储右视图的结果

        if (!root) return {};   // 如果树为空，返回空数组

        que.push(root);         // 把根节点加入队列

        while (que.size()) {    // 当队列不为空时，持续处理每一层
            int n = que.size(); // 当前层的节点数量

            // 遍历当前层的所有节点
            for (int i = 0; i < n; i++) {
                TreeNode* node = que.front(); // 获取当前队首节点

                // 如果是当前层的最后一个节点，将它加入结果中（右视图）
                if (i == n - 1) res.push_back(node->val);

                que.pop(); // 弹出当前节点

                // 将下一层的左右子节点加入队列（先左后右）
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }

        return res; // 返回右视图结果
    }
};

```

