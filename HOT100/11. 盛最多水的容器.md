# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个长度为 `n` 的整数数组`height`。有`n`条垂线，第 `i` 条线的两个端点是`(i, 0)`和`(i, height[i])`。

找出其中的两条线，使得它们与`x`轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：** 你不能倾斜容器。

**示例 1：** 

<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508062244601.jpg">

```
**输入：** [1,8,6,2,5,4,8,3,7]
**输出：** 49 
**解释：** 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。```

**示例 2：** 

```
**输入：** height = [1,1]
**输出：** 1
```

**提示：** 

- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`
```

## Solution

双指针（对所有搜索情况进行剪枝，最后只遍历`min(height[left], height[right])`）

## Code

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        // 使用双指针法，从两端向中间逼近
        int left = 0;                    // 左指针，初始指向最左边
        int right = height.size() - 1;   // 右指针，初始指向最右边
        int mx = 0;                      // 用于记录最大面积

        while (left < right) {
            // 计算当前区域的面积：取左右指针中较小的高度 * 宽度
            int curArea = min(height[left], height[right]) * (right - left);
            mx = max(mx, curArea); // 更新最大面积

            // 移动较短的一边，因为只有移动较短边才有可能增大面积
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return mx; // 返回最大水容积
    }
};

```

