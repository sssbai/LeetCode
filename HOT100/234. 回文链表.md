# [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个单链表的头节点 `head` ，请你判断该链表是否为<button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">回文链表</button>。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508052337163.jpg" style="width: 422px; height: 62px;">

```
**输入：** head = [1,2,2,1]
**输出：** true
```

**示例 2：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508052337452.jpg" style="width: 182px; height: 62px;">

```
**输入：** head = [1,2]
**输出：** false
```

**提示：** 

- 链表中节点数目在范围`[1, 10^5]` 内
- `0 <= Node.val <= 9`

**进阶：** 你能否用`O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

## Solution

查找链表中间节点，反转链表，比对链表数值

## Code

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 快慢指针法获取链表的中点
    ListNode* getmid(ListNode* node){
        ListNode* slow = node;  // 慢指针每次走1步
        ListNode* fast = node;  // 快指针每次走2步

        // 快指针走到尽头时，慢指针正好在中点
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;  // 返回链表中点
    }

    // 翻转链表，返回新链表头节点
    ListNode* getrev(ListNode* node){
        ListNode* dummy = new ListNode();  // 哑节点，头插法构造新链表

        while(node){
            ListNode* tmp = node;       // 记录当前节点
            node = node->next;          // 向后走
            tmp->next = dummy->next;    // 将当前节点插入到dummy之后
            dummy->next = tmp;
        }

        return dummy->next;  // 返回新链表的头节点
    }

    // 主函数：判断是否是回文链表
    bool isPalindrome(ListNode* head) {
        ListNode* mid = getmid(head);      // 获取中点
        ListNode* head2 = getrev(mid);     // 翻转后半部分链表

        // 比较前半部分和翻转后的后半部分
        while(head2){
            if(head->val != head2->val){   // 一旦不相等则不是回文
                return false;
            }
            head = head->next;
            head2 = head2->next;
        }

        return true;  // 全部相等则是回文链表
    }
};

```

