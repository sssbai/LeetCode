# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效**  二叉搜索树定义如下：

- 节点的左<button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子树</button>只包含**严格小于 ** 当前节点的数。
- 节点的右子树只包含 **严格大于**  当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508052057274.jpg" style="width: 302px; height: 182px;">

```
**输入：** root = [2,1,3]
**输出：** true
```

**示例 2：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508052057464.jpg" style="width: 422px; height: 292px;">

```
**输入：** root = [5,1,4,null,null,3,6]
**输出：** false
**解释：** 根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：** 

- 树中节点数目范围在`[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

## Solution

### 方法一：前序遍历

*dfs* 额外传入两个参数，分别表示从根到当前节点路径上的最小值和最大值。

当前节点的值必须在最小值和最大值之间（不能等于）

## Code

### 前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // 辅助函数，用于递归地验证每个节点是否符合 BST 的定义
    // left 和 right 表示当前子树合法的取值范围
    bool prejudge(TreeNode* node, long long left = INT64_MIN, long long right = INT64_MAX){
        if (!node) return true;  // 空节点是合法的 BST

        long long x = node->val;  // 当前节点的值，转为 long long 以避免越界

        // 判断当前节点是否在合法范围内，并递归检查左右子树
        return x > left && x < right
            && prejudge(node->left, left, x)    // 左子树所有值必须 < 当前节点值
            && prejudge(node->right, x, right); // 右子树所有值必须 > 当前节点值
    }

    // 主函数，调用递归判断逻辑
    bool isValidBST(TreeNode* root) {
        return prejudge(root);
    }
};

```

