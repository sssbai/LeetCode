# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉树的根节点 `root` ，返回 它的 **中序** 遍历 。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202507310001251.jpg" style="height: 200px; width: 125px;">

```
**输入：** root = [1,null,2,3]
**输出：** [1,3,2]
```

**示例 2：** 

```
**输入：** root = []
**输出：** []
```

**示例 3：** 

```
**输入：** root = [1]
**输出：** [1]
```

**提示：** 

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

## Solution

简单的递归思路，迭代就是使用队列来访问

[二叉树的前中后序的迭代遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/34581/die-dai-fa-by-jason-2)

[通用颜色标记法](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming)

## Code

### 递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    void getmid(TreeNode* node){
        if(node == nullptr)return;
        getmid(node->left);
        res.push_back(node->val);
        getmid(node->right);
        return ;

    }
    vector<int> inorderTraversal(TreeNode* root) {
        getmid(root);
        return res;
    }
};
```

### 迭代

```c++
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> S;
        vector<int> v;
        TreeNode* rt = root;
        while(rt || S.size()){
            while(rt){
                S.push(rt);
                rt=rt->left;
            }
            rt=S.top();S.pop();
            v.push_back(rt->val);
            rt=rt->right;
        }
        return v;        
    }
```

### 通用颜色标记法

```c++
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res
```

