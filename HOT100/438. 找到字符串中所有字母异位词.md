# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

给定两个字符串`s`和 `p`，找到`s`**** 中所有`p`**** 的**<button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">异位词</button>** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例1:** 

```
**输入: ** s = "cbaebabacd", p = "abc"
**输出: ** [0,6]
**解释:** 
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**示例 2:** 

```
**输入: ** s = "abab", p = "ab"
**输出: ** [0,1,2]
**解释:** 
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:** 

- `1 <= s.length, p.length <= 3 * 10^4`
- `s`和`p`仅包含小写字母

## Solution

定长滑动窗口

不定长滑动窗口

## Code

### 定长滑动窗口

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        // int res1[26] = {0}, res2[26] = {0};不支持直接比较
        // unordered_map<int, int> res1, res2;在检查新的字母时，会自动创建新的映射无法来进行有效的比较
        // array<int, 26> res1={0}, res2={0};固定大小，且支持直接比较
        // string pp = string(26, '0');使用字符串的方式也可以
        array<int, 26> res1={0}, res2={0};
        for(auto v: p){
            res1[v-'a']++;
        }
        vector<int> out;
        for(int right = 0;right < s.size(); right++){
            res2[s[right]-'a']++;
            int left = right-p.size()+1;
            if(left<0){
                continue;
            }
            if(res1==res2){
                out.push_back(left);
            }
            res2[s[left]-'a']--;
        }
        return out;
    }
};
```

### 不定长滑动窗口

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<int, int> res; // 记录字符串 p 中每个字符的出现次数
        int typecount = 0; // 不同字符的种类数（即需要匹配的字符种类数）

        // 统计目标字符串 p 中每个字符的频次，并记录种类数
        for (auto v : p) {
            if (res[v] == 0) typecount++; // 第一次遇到该字符，种类数加一
            res[v]++;
        }

        int left = 0; // 滑动窗口左边界
        vector<int> out; // 存储结果的起始下标

        // 使用滑动窗口遍历 s
        for (int right = 0; right < s.size(); right++) {
            res[s[right]]--; // 当前字符加入窗口，相应字符频次减一
            if (res[s[right]] == 0) {
                typecount--; // 当前字符完全匹配（频次为 0），种类数减一
            }

            // 当所有字符都被匹配（种类数为 0）
            while (typecount == 0) {
                // 如果窗口大小等于 p 的长度，说明是一个合法的异位词
                if (right - left + 1 == p.size()) {
                    out.push_back(left);
                }

                // 将窗口左侧字符移出，恢复其频次
                if (res[s[left]] == 0) {
                    typecount++; // 被移出的字符将不再匹配，种类数加一
                }
                res[s[left]]++; // 恢复该字符的频次
                left++; // 缩小窗口左边界
            }
        }
        return out; // 返回所有起始索引
    }
};

```

