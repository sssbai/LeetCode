# [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个包含`n + 1` 个整数的数组`nums` ，其数字都在`[1, n]`范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数**  ，返回**这个重复的数**  。

你设计的解决方案必须 **不修改**  数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：** 

```
**输入：** nums = [1,3,4,2,2]
**输出：** 2
```

**示例 2：** 

```
**输入：** nums = [3,1,3,4,2]
**输出：** 3
```

**示例 3 :** 

```
**输入：** nums = [3,3,3,3,3]
**输出：** 3
```

**提示：** 

- `1 <= n <= 10^5`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数**  出现 **两次或多次**  ，其余整数均只出现 **一次** 

<b>进阶：</b>

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

## Solution

快慢指针-环形链表

## Code

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // 初始化三个指针：slow 和 fast 用于检测环，head 用于找到环的入口
        int slow = 0, fast = 0, head = 0;
        int n = nums.size();

        // 使用 Floyd 判圈法，寻找快慢指针第一次相遇的点
        while (fast < n && nums[fast] < n) {
            slow = nums[slow];             // 慢指针每次走一步
            fast = nums[nums[fast]];       // 快指针每次走两步

            if (fast == slow) {
                // 快慢指针相遇，说明存在环（即存在重复数字）

                // 重置 head 指针为起点，与 slow 同步移动，寻找环的入口
                while (head != slow) {
                    slow = nums[slow];
                    head = nums[head];
                }

                // 相遇点即为重复数字
                return head;
            }
        }

        // 如果未找到重复元素（按题意不会发生），默认返回 0
        return 0;
    }
};

```

