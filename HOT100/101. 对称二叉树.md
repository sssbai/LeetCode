# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508061650669.png" style="width: 354px; height: 291px;">

```
**输入：** root = [1,2,2,3,4,4,3]
**输出：** true
```

**示例 2：** 
<img alt="" src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" style="width: 308px; height: 258px;">

```
**输入：** root = [1,2,2,null,3,null,3]
**输出：** false
```

**提示：** 

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？

## Solution

简单的dfs

## Code

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 判断两个子树是否是镜像对称的
    bool judge(TreeNode* node1, TreeNode* node2) {
        // 如果有一个节点为空，两个必须都为空才对称
        if (!node1 || !node2) {
            return node1 == node2;  // 同时为空返回 true，否则 false
        }

        // 判断当前两个节点的值是否相等，
        // 并递归判断 node1 的左子树与 node2 的右子树是否对称，
        // 以及 node1 的右子树与 node2 的左子树是否对称
        return node1->val == node2->val &&
               judge(node1->left, node2->right) &&
               judge(node1->right, node2->left);
    }

    // 主函数：判断一棵树是否对称
    bool isSymmetric(TreeNode* root) {
        return judge(root, root); // 判断 root 与自身是否对称
    }
};

```

