# [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个只包含 `'('`和 `')'`的字符串，找出最长有效（格式正确且连续）括号<button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子串</button>的长度。

<div class="original__bRMd">

**示例 1：** 

```
**输入：** s = "(()"
**输出：** 2
**解释：** 最长有效括号子串是 "()"
```

**示例 2：** 

```
**输入：** s = ")()())"
**输出：** 4
**解释：** 最长有效括号子串是 "()()"
```

**示例 3：** 

```
**输入：** s = ""
**输出：** 0
```

**提示：** 

- `0 <= s.length <= 3 * 10^4`
- `s[i]` 为 `'('` 或 `')'`

## Solutions:

1. 栈+标记数组

## Codes：

### 栈 + 标记数组

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;                     // 栈，用于存储左括号的下标
        vector<int> mark(s.size(), 0);     // 标记数组，标记匹配成功的位置

        // 第一遍遍历，用栈匹配括号
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                st.push(i);                // 记录左括号下标
            } else {
                if (!st.empty()) {
                    // 成功匹配：当前是 ')' 且栈顶是 '('
                    mark[i] = 1;
                    mark[st.top()] = 1;
                    st.pop();              // 弹出匹配的 '('
                }
            }
        }

        // 第二遍遍历 mark 数组，寻找连续的 1 的最大长度
        int maxLen = 0, curLen = 0;
        for (int v : mark) {
            if (v == 1) {
                curLen++;
            } else {
                maxLen = max(maxLen, curLen);
                curLen = 0;
            }
        }
        maxLen = max(maxLen, curLen); // 处理最后一段连续匹配

        return maxLen;
    }
};

```

