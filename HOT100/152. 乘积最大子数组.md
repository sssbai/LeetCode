# [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums`，请你找出数组中乘积最大的非空连续 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">子数组</button>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个**32-位**  整数。

<strong class="example">示例 1:** 

```
**输入:**  nums = [2,3,-2,4]
**输出:**  `6`
**解释:** 子数组 [2,3] 有最大乘积 6。
```

<strong class="example">示例 2:** 

```
**输入:**  nums = [-2,0,-1]
**输出:**  0
**解释:** 结果不能为 2, 因为 [-2,-1] 不是子数组。```

**提示:** 

- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位**  整数
```

## Solutions:

这题算是==连续子集问题==

1. 动态规划
2. 记忆化搜索

## Code：

### 动态规划

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> fmax(n);
        vector<int> fmin(n);
        // fmax[i] = max({nums[i], fmax[i-1]*nums[i], fmin[i-1]*nums[i]});
        // fmin[i] = min({nums[i], fmax[i-1]*nums[i], fmin[i-1]*nums[i]});
        fmax[0] = fmin[0] = nums[0];
        for(int i = 1; i < n; i++){
            fmax[i] = max({nums[i], fmax[i-1]*nums[i], fmin[i-1]*nums[i]});
            fmin[i] = min({nums[i], fmin[i-1]*nums[i], fmax[i-1]*nums[i]});
        }
        int res = INT32_MIN;
        for(auto& value: fmax){
            res = max(res, value);
        }
        return res;
    }
};
```





