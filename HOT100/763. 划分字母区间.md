# [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串`"ababcc"` 能够被分为 `["abab", "cc"]`，但类似`["aba", "bcc"]` 或`["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

<strong class="example">示例 1：** 

```
**输入：** s = "ababcbacadefegdehijhklij"
**输出：** [9,7,8]
**解释：** 
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 ```

<strong class="example">示例 2：** 

```
**输入：** s = "eccbbbbdec"
**输出：** [10]
```

**提示：** 

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成
```

## Solution

合并区间

## Code

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> res;                 // 存储每个分区的长度
        vector<int> last_i(26);         // 记录每个字符最后一次出现的位置（字母表大小为26）

        // 第一步：记录每个字符最后一次出现的位置
        for (int i = 0; i < s.size(); i++) {
            last_i[s[i] - 'a'] = i;
        }

        int start = 0, end = 0;         // 当前分区的起始和结束位置

        // 第二步：遍历字符串，动态更新当前分区的结束位置
        for (int i = 0; i < s.size(); i++) {
            end = max(end, last_i[s[i] - 'a']);  // 更新当前字符所在分区的最远结束位置

            if (i == end) {
                // 如果当前位置正好是当前分区的结束位置，记录该分区长度
                res.push_back(end - start + 1);
                start = i + 1;  // 开始一个新的分区
            }
        }

        return res;
    }
};

```

