# [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s`，找到 `s` 中最长的 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">回文</button> <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">子串</button>。

**示例 1：** 

```
**输入：** s = "babad"
**输出：** "bab"
**解释：** "aba" 同样是符合题意的答案。
```

**示例 2：** 

```
**输入：** s = "cbbd"
**输出：** "bb"
```

**提示：** 

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## Solutions

1. 中心扩散法
2. 动态规划法
3. manacher算法

## Code:

### 中心扩散法

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        // 对原字符串进行预处理，在每个字符间插入 '#'，使奇偶回文统一处理
        string ns;
        for (int i = 0; i < s.size(); i++) {
            if (i == 0) ns += "#";
            ns += s[i];
            ns += "#";
        }

        int res = 0;      // 最长回文长度（注意此处计算的是处理后字符串的长度）
        int left = 0;     // 原始字符串中的起始位置
        int right = 0;    // 原始字符串中的结束位置

        // 枚举每个字符作为回文中心，向两边扩展
        for (int i = 0; i < ns.size(); i++) {
            int l = i, r = i;

            // 向左右扩展，直到不相等或越界
            while (l - 1 >= 0 && r + 1 < ns.size() && ns[l - 1] == ns[r + 1]) {//⚠️注意，这里必须是先判断再获取，因为l，r分别表示最长子串的起始和结束下标
                l--;
                r++;
            }

            int lens = r - l;  // 回文长度
            if (lens > res) {
                res = lens;
                left = l / 2;   // 映射回原字符串的起始位置
                right = r / 2;  // 映射回原字符串的结束位置（不包含）
            }
        }

        // 返回原始字符串中最长回文子串
        return string(s.begin() + left, s.begin() + right);
    }
};

```

