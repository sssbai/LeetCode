# [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s`，找到 `s` 中最长的 <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1a:" data-state="closed" class="">回文</button> <button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:r1b:" data-state="closed" class="">子串</button>。

**示例 1：** 

```
**输入：** s = "babad"
**输出：** "bab"
**解释：** "aba" 同样是符合题意的答案。
```

**示例 2：** 

```
**输入：** s = "cbbd"
**输出：** "bb"
```

**提示：** 

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## Solutions

1. 中心扩散法
2. 动态规划法
3. manacher算法

## Code:

### 中心扩散法

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        // 对原字符串进行预处理，在每个字符间插入 '#'，使奇偶回文统一处理
        string ns;
        for (int i = 0; i < s.size(); i++) {
            if (i == 0) ns += "#";
            ns += s[i];
            ns += "#";
        }

        int res = 0;      // 最长回文长度（注意此处计算的是处理后字符串的长度）
        int left = 0;     // 原始字符串中的起始位置
        int right = 0;    // 原始字符串中的结束位置

        // 枚举每个字符作为回文中心，向两边扩展
        for (int i = 0; i < ns.size(); i++) {
            int l = i, r = i;

            // 向左右扩展，直到不相等或越界
            while (l - 1 >= 0 && r + 1 < ns.size() && ns[l - 1] == ns[r + 1]) {//⚠️注意，这里必须是先判断再获取，因为l，r分别表示最长子串的起始和结束下标
                l--;
                r++;
            }

            int lens = r - l;  // 回文长度
            if (lens > res) {
                res = lens;
                left = l / 2;   // 映射回原字符串的起始位置
                right = r / 2;  // 映射回原字符串的结束位置（不包含）
            }
        }

        // 返回原始字符串中最长回文子串
        return string(s.begin() + left, s.begin() + right);
    }
};

```

### Manacher

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";

        // Step 1: 插值处理，将字符串变成间隔#的形式，统一奇偶情况
        // 例如: "abc" -> "#a#b#c#"
        string t = "#";
        for (char c : s) {
            t += c;
            t += "#";
        }

        int n = t.size();
        vector<int> p(n, 0); // p[i]: 以 i 为中心的最长回文半径（不包含中心）

        // 当前已知的最右回文的右边界 right，及其对应的中心 center
        int center = 0, right = 0;

        // 最长回文子串的中心和半径
        int maxCenter = 0, maxRadius = 0;

        for (int i = 0; i < n; ++i) {
            // Step 2: 初始化回文半径
            if (i < right) {
                int mirror = 2 * center - i;  // i 关于 center 的对称点
                p[i] = min(p[mirror], right - i);
            } else {
                p[i] = 0;
            }

            // Step 3: 向左右扩展
            while (i - p[i] - 1 >= 0 && i + p[i] + 1 < n && t[i - p[i] - 1] == t[i + p[i] + 1]) {
                ++p[i];
            }

            // Step 4: 更新最右边界
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }

            // Step 5: 记录最长回文子串
            if (p[i] > maxRadius) {
                maxRadius = p[i];
                maxCenter = i;
            }
        }

        // Step 6: 从原始字符串中提取结果
        // 由于插值后的位置映射关系为：原始位置 i -> 2*i + 1
        // 所以原始起始位置为：(maxCenter - maxRadius) / 2
        int start = (maxCenter - maxRadius) / 2;
        return s.substr(start, maxRadius);
    }
};

```

