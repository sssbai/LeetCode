# [51. N 皇后](https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n皇后问题**  研究的是如何将 `n`个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的**n皇后问题**  的解决方案。

<div class="original__bRMd">

每一种解法包含一个不同的**n 皇后问题**  的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：** 
<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508071538263.jpg" style="width: 600px; height: 268px;">

```
**输入：** n = 4
**输出：** [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
**解释：** 如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：** 

```
**输入：** n = 1
**输出：** [["Q"]]
```

**提示：** 

- `1 <= n <= 9`

## Solution

DFS+回溯

## Code

```c++
class Solution {
public:
    vector<vector<string>> res; // 用于存放所有可行解
    vector<int> tag; // tag[j] = i 表示第 j 列的第 i 行放置了皇后，用于标记列是否被占用

    // 判断当前位置 (x, y) 是否可以放置皇后
    bool judge(int x, int y, int n){
        if(tag[y] != -1) return false; // 如果第 y 列已经放了皇后，不能再放
        else {
            // 检查左上对角线是否有皇后
            int tx = x, ty = y;
            while (--tx >= 0 && --ty >= 0) {
                if (tag[ty] == tx) return false;
            }

            // 检查右上对角线是否有皇后
            tx = x; ty = y;
            while (--tx >= 0 && ++ty < n) {
                if (tag[ty] == tx) return false;
            }

            // 没有冲突，可以放置
            return true;
        }
    }

    // 回溯搜索函数
    void getba(int n, int i, vector<string> path){
        if (i == n) {
            // 找到一个完整解，加入结果集
            res.push_back(path);
            return;
        }

        // 尝试在第 i 行的每一列放置皇后
        for (int j = 0; j < n; j++) {
            if (judge(i, j, n)) {
                tag[j] = i;           // 标记第 j 列在第 i 行放了皇后
                path[i][j] = 'Q';     // 在 path 中记录皇后位置
                getba(n, i + 1, path); // 递归到下一行
                path[i][j] = '.';     // 回溯，撤销放置
                tag[j] = -1;          // 清除标记
            }
        }
    }

    // 主函数
    vector<vector<string>> solveNQueens(int n) {
        tag.resize(n, -1); // 初始化所有列都没有放皇后
        vector<string> path(n, string(n, '.')); // 初始化空棋盘
        getba(n, 0, path); // 从第 0 行开始回溯搜索
        return res; // 返回所有可行解
    }
};

```

