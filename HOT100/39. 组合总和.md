# [39. 组合总和](https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个 **无重复元素**  的整数数组`candidates` 和一个目标整数`target`，找出`candidates`中可以使数字和为目标数`target` 的 所有**不同组合**  ，并以列表形式返回。你可以按 **任意顺序**  返回这些组合。

`candidates` 中的 **同一个**  数字可以 **无限制重复被选取**  。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为`target` 的不同组合数少于 `150` 个。

**示例1：** 

```
**输入：** candidates = `[2,3,6,7]`, target = `7`
**输出：** [[2,2,3],[7]]
**解释：** 
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。```

**示例2：** 

```
**输入: ** candidates = [2,3,5]`, `target = 8
**输出: ** [[2,2,2,2],[2,3,3],[3,5]]```

**示例 3：** 

```
**输入: ** candidates = `[2], `target = 1
**输出: ** []
```

**提示：** 

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同** 
- `1 <= target <= 40`

## Solution

回溯

## Code

```c++
class Solution {
public:
    vector<vector<int>> result;  // 存储最终所有满足条件的组合

    /**
     * 回溯搜索函数
     * @param candidates 候选数字数组
     * @param x 当前考虑到第 x 个元素（下标）
     * @param y 当前剩余的目标值
     * @param path 当前构造中的组合路径
     */
    void dfs(vector<int>& candidates, int x, int y, vector<int> path) {
        // 如果所有元素都遍历完了
        if (x < 0) {
            // 如果剩余目标值为 0，说明找到一组合法组合
            if (y == 0) {
                result.push_back(path);  // 加入结果集
            }
            return;
        }

        // 尝试选择 candidates[x]（前提是它不大于剩余目标值）
        if (candidates[x] <= y) {
            path.push_back(candidates[x]);               // 做出选择
            dfs(candidates, x, y - candidates[x], path); // 继续选当前元素（可重复）
            path.pop_back();                             // 撤销选择（回溯）
        }

        // 尝试跳过当前元素，考虑下一个（下标减一）
        dfs(candidates, x - 1, y, path);
        return;
    }

    /**
     * 主函数：给定一个数组 candidates 和目标值 target，找出所有不重复的组合，使得它们的和为 target。
     * 数组中的元素可以被无限次使用。
     */
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        int n = candidates.size();
        dfs(candidates, n - 1, target, {});  // 从最后一个元素开始回溯搜索
        return result;  // 返回所有合法组合
    }
};

```

