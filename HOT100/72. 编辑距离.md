# [72. 编辑距离](https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

给你两个单词`word1` 和`word2`， 请返回将`word1`转换成`word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例1：** 

```
**输入：** word1 = "horse", word2 = "ros"
**输出：** 3
**解释：** 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例2：** 

```
**输入：** word1 = "intention", word2 = "execution"
**输出：** 5
**解释：** 
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：** 

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

## Solutions

1. 记忆化搜索

## Codes

```c++
class Solution {
public:
    // 记忆化数组，mem[i][j] 表示 w1[0..i] 到 w2[0..j] 的最小编辑距离
    vector<vector<int>> mem;
    string w1, w2;

    // DFS + 记忆化搜索
    int dfs(int i, int j) {
        // 如果 w1 已经为空，剩下的 j+1 个字符需要插入
        if (i < 0) return j + 1;

        // 如果 w2 已经为空，剩下的 i+1 个字符需要删除
        if (j < 0) return i + 1;

        int& res = mem[i][j];
        if (res != -1) return res;

        // 如果当前字符相等，不需要操作，递归处理前面的字符
        if (w1[i] == w2[j]) {
            return res = dfs(i - 1, j - 1);
        } else {
            // 三种操作：
            // 1. 删除 w1[i] => dfs(i-1, j) + 1
            // 2. 插入 w2[j] 到 w1 => dfs(i, j-1) + 1
            // 3. 替换 w1[i] -> w2[j] => dfs(i-1, j-1) + 1
            return res = min({
                dfs(i - 1, j) + 1,     // 删除
                dfs(i, j - 1) + 1,     // 插入
                dfs(i - 1, j - 1) + 1  // 替换
            });
        }
    }

    int minDistance(string word1, string word2) {
        w1 = word1;
        w2 = word2;
        int len1 = w1.size();
        int len2 = w2.size();

        // 初始化记忆化数组为 -1
        mem = vector<vector<int>>(len1, vector<int>(len2, -1));

        // 从最后一个字符开始向前递归
        return dfs(len1 - 1, len2 - 1);
    }
};

```

