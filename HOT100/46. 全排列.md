# [46. 全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个不含重复数字的数组 `nums` ，返回其 所有可能的全排列 。你可以 **按任意顺序**  返回答案。

**示例 1：** 

```
**输入：** nums = [1,2,3]
**输出：** [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：** 

```
**输入：** nums = [0,1]
**输出：** [[0,1],[1,0]]
```

**示例 3：** 

```
**输入：** nums = [1]
**输出：** [[1]]
```

**提示：** 

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

## Solution

回溯算法

## Code

```c++
class Solution {
public:
    vector<vector<int>> res; // 存储所有排列结果
    int n; // 输入数组的长度
    vector<int> mem; // 标记数组，用于记录某个元素是否已经被使用

    // 深度优先搜索函数，用于生成排列
    void dfs(vector<int>& nums, vector<int> path) {
        // 如果当前路径长度等于数组长度，说明是一个完整的排列
        if (path.size() == n) {
            res.push_back(path); // 将当前排列加入结果集
            return;
        }
        // 遍历每一个元素，尝试将其加入当前排列
        for (int j = 0; j < n; j++) {
            if (mem[j] == 0) { // 如果当前元素还未被使用
                mem[j] = 1; // 标记为已使用
                path.push_back(nums[j]); // 加入当前排列路径
                dfs(nums, path); // 递归调用，继续构造排列
                path.pop_back(); // 回溯，移除最后加入的元素
                mem[j] = 0; // 回溯，标记为未使用
            }
        }
    }

    // 主函数，用于初始化变量并调用 dfs
    vector<vector<int>> permute(vector<int>& nums) {
        n = nums.size(); // 获取输入数组长度
        mem.resize(n, 0); // 初始化标记数组
        dfs(nums, {}); // 从空路径开始进行深度优先搜索
        return res; // 返回所有排列结果
    }
};

```

