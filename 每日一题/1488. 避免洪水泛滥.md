# [1488. 避免洪水泛滥](https://leetcode.cn/problems/avoid-flood-in-the-city/description/?envType=daily-question&envId=2025-10-07)

你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 `n`个湖泊下雨前是空的，那么它就会装满水。如果第 `n`个湖泊下雨前是 **满的** ，这个湖泊会发生 **洪水**  。你的目标是避免任意一个湖泊发生洪水。

给你一个整数数组`rains`，其中：

- `rains[i] > 0`表示第 `i`天时，第 `rains[i]`个湖泊会下雨。
- `rains[i] == 0`表示第 `i`天没有湖泊会下雨，你可以选择 **一个** 湖泊并 **抽干** 这个湖泊的水。

请返回一个数组`ans`，满足：

- `ans.length == rains.length`
- 如果`rains[i] > 0` ，那么`ans[i] == -1`。
- 如果`rains[i] == 0`，`ans[i]`是你第`i`天选择抽干的湖泊。

如果有多种可行解，请返回它们中的 **任意一个** 。如果没办法阻止洪水，请返回一个 **空的数组** 。

请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。

**示例 1：** 

```
**输入：** rains = [1,2,3,4]
**输出：** [-1,-1,-1,-1]
**解释：** 第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，装满水的湖泊包括 [1,2,3]
第四天后，装满水的湖泊包括 [1,2,3,4]
没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。
```

**示例 2：** 

```
**输入：** rains = [1,2,0,0,2,1]
**输出：** [-1,-1,2,1,-1,-1]
**解释：** 第一天后，装满水的湖泊包括 [1]
第二天后，装满水的湖泊包括 [1,2]
第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]
第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。
第五天后，装满水的湖泊包括 [2]。
第六天后，装满水的湖泊包括 [1,2]。
可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。
```

**示例 3：** 

```
**输入：** rains = [1,2,0,1,2]
**输出：** []
**解释：** 第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。
但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。
```

**提示：** 

- `1 <= rains.length <= 10^5`
- `0 <= rains[i] <= 10^9`

## Solution

方法一、采用有序集合，时间复杂度为$O(n\log n)$，空间复杂度为$O(n)$

方法二、采用并查集，时间复杂度为$O(n)$，空间复杂度为$O(n)$

## Code

有序集合

```c++
class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) {
        int n = rains.size();
        vector<int> ans(n, -1);
        set<int> empty; // empty size
        unordered_map<int, int> umap;
        for(int i = 0; i < n; i++){
            if(rains[i] == 0){
                ans[i] = 1;
                empty.insert(i);
            }
            else{
                if(umap.contains(rains[i])){
                    int j = umap[rains[i]];
                    auto it = empty.upper_bound(j);
                    if(it == empty.end())return {};
                    else{
                        ans[*it] = rains[i];
                        umap[rains[i]] = i;
                        empty.erase(*it);
                    }
                }
                else{
                    umap[rains[i]] = i;
                }
            }
        }
        return ans;
    }
};
```

并查集

```c++
class Solution {
public:
    vector<int> fa;
    int find(int x){
        if(fa[x] != x){
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }
    vector<int> avoidFlood(vector<int>& rains) {
        int n = rains.size();
        fa.resize(n+1);
        for(int i = 0; i < n + 1; i++){
            fa[i] = i; // 表明当前日期下对应的父亲节点为自己。这里表明当前日期为抽干湖泊的日期
        }
        vector<int> ans(n, -1);
        unordered_map<int, int> full_day; // 字典记录信息， {湖泊编号：装满的日期}
        for(int i = 0; i < n; i++){
            int lake = rains[i]; // 获取湖泊编号
            if(lake == 0){ // 如果湖泊编号为0，则表示可以任意抽干一个湖泊，这里是随机的，所以直接填写1
                ans[i] = 1;
                continue;
            }
            if(full_day.contains(lake)){ // 如果该湖泊之前被装满，则需要进行以下操作
                int j = full_day[lake]; // 获取该湖泊之前装满的日期
                int dry_day = find(j); // 通过并查集，找到最终的父节点
                if(dry_day == i){ // 如果当前父节点的日期是等于当前日期的，则说明没有抽干的机会了
                    return {};
                }
                ans[dry_day] = lake; // 记录抽干日期对应的湖泊编号
                fa[dry_day] = find(dry_day + 1); // 将该日期的父节点更新为find(dry_day+1)，表示该次抽干机会已经被使用
            }
            fa[i] = i + 1; // 记录当前日期的父亲节点为下一个日期，表明当前日期下没有抽干湖泊的机会
            full_day[lake] = i; // 记录当前湖泊被装满的日期
        }
        return ans;
    }
};
```

