# [3439. 重新安排会议得到最多空余时间 I](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/description/)

给你一个整数`eventTime`表示一个活动的总时长，这个活动开始于`t = 0`，结束于`t = eventTime`。

同时给你两个长度为 `n`的整数数组`startTime` 和`endTime`。它们表示这次活动中 `n`个时间**没有重叠** 的会议，其中第`i`个会议的时间为`[startTime[i], endTime[i]]`。

你可以重新安排 **至多** `k`个会议，安排的规则是将会议时间平移，且保持原来的 **会议时长** ，你的目的是移动会议后 **最大化** 相邻两个会议之间的 **最长**  连续空余时间。

移动前后所有会议之间的 **相对** 顺序需要保持不变，而且会议时间也需要保持互不重叠。

请你返回重新安排会议以后，可以得到的 **最大** 空余时间。

<b>注意</b>，会议 **不能** 安排到整个活动的时间以外。

<strong class="example">示例 1：** 

<div class="example-block">
<b>输入：</b>eventTime = 5, k = 1, startTime = [1,3], endTime = [2,5]

<b>输出：</b>2

**解释：** 

<img alt="" src="https://gitee.com/baishuaishuai/saveimg/raw/master/202508231647558.png" style="width: 375px; height: 123px;">

将`[1, 2]`的会议安排到`[2, 3]`，得到空余时间`[0, 2]`。

<strong class="example">示例 2：** 

<div class="example-block">
<b>输入：</b>eventTime = 10, k = 1, startTime = [0,2,9], endTime = [1,4,10]

<b>输出：</b>6

**解释：** 

<img alt="" src="https://assets.leetcode.com/uploads/2024/12/21/example1_rescheduled.png" style="width: 375px; height: 125px;">

将`[2, 4]`的会议安排到`[1, 3]`，得到空余时间`[3, 9]`。

<strong class="example">示例 3：** 

<div class="example-block">
<b>输入：</b>eventTime = 5, k = 2, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]

<b>输出：</b>0

**解释：** 

活动中的所有时间都被会议安排满了。

**提示：** 

- `1 <= eventTime <= 10^9`
- `n == startTime.length == endTime.length`
- `2 <= n <= 10^5`
- `1 <= k <= n`
- `0 <= startTime[i] < endTime[i] <= eventTime`
- `endTime[i] <= startTime[i + 1]` 其中`i`在范围`[0, n - 2]`之间。

## Solution

## Code

```c++
class Solution {
public:
    int maxFreeTime(int eventTime, int k, vector<int>& startTime, vector<int>& endTime) {
        vector<int> btime;
        for(int i = 0; i < startTime.size(); i++){
            if(i==0){
                btime.push_back(startTime[i]);
            }
            else{
                btime.push_back(startTime[i]-endTime[i-1]);
            }
            if(i==startTime.size()-1){
                btime.push_back(eventTime-endTime[i]);
            }
        }
        int left = 0;
        int count = 0;
        int res = 0;
        for(int right = 0; right< btime.size(); right++){
            count+=btime[right];
            if(right-left+1<k+1){
                continue;
            }
            res = max(res, count);
            count-=btime[left];
            left++;
        }
        return res;
    }
};
```

