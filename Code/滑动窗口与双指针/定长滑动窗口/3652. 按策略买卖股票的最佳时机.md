# [3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)

给你两个整数数组 `prices` 和 `strategy`，其中：

- `prices[i]` 表示第 `i` 天某股票的价格。
- `strategy[i]` 表示第 `i` 天的交易策略，其中：

- `-1` 表示买入一单位股票。
- `0` 表示持有股票。
- `1` 表示卖出一单位股票。

同时给你一个**偶数** 整数 `k`，你可以对 `strategy` 进行**最多一次** 修改。一次修改包括：

- 选择 `strategy` 中恰好 `k` 个**连续** 元素。
- 将前 `k / 2` 个元素设为 `0`（持有）。
- 将后 `k / 2` 个元素设为 `1`（卖出）。

**利润** 定义为所有天数中 `strategy[i] * prices[i]` 的**总和** 。

返回你可以获得的**最大** 可能利润。

**注意：**  没有预算或股票持有数量的限制，因此所有买入和卖出操作均可行，无需考虑过去的操作。

<strong class="example">示例 1：** 

<div class="example-block">
**输入：**  prices = [4,2,8], strategy = [-1,0,1], k = 2

**输出：**  10

**解释：** 

<table style="border: 1px solid black;"><thead><tr><th style="border: 1px solid black;">修改</th><th style="border: 1px solid black;">策略</th><th style="border: 1px solid black;">利润计算</th><th style="border: 1px solid black;">利润</th></tr></thead><tbody><tr><td style="border: 1px solid black;">原始</td><td style="border: 1px solid black;">[-1, 0, 1]</td><td style="border: 1px solid black;">(-1 × 4) + (0 × 2) + (1 × 8) = -4 + 0 + 8</td><td style="border: 1px solid black;">4</td></tr><tr><td style="border: 1px solid black;">修改 [0, 1]</td><td style="border: 1px solid black;">[0, 1, 1]</td><td style="border: 1px solid black;">(0 × 4) + (1 × 2) + (1 × 8) = 0 + 2 + 8</td><td style="border: 1px solid black;">10</td></tr><tr><td style="border: 1px solid black;">修改 [1, 2]</td><td style="border: 1px solid black;">[-1, 0, 1]</td><td style="border: 1px solid black;">(-1 × 4) + (0 × 2) + (1 × 8) = -4 + 0 + 8</td><td style="border: 1px solid black;">4</td></tr></tbody></table>

因此，最大可能利润是 10，通过修改子数组 `[0, 1]` 实现。

<strong class="example">示例 2：** 

<div class="example-block">
**输入：**  prices = [5,4,3], strategy = [1,1,0], k = 2

**输出：**  9

**解释：** 

<div class="example-block">
<table style="border: 1px solid black;"><thead><tr><th style="border: 1px solid black;">修改</th><th style="border: 1px solid black;">策略</th><th style="border: 1px solid black;">利润计算</th><th style="border: 1px solid black;">利润</th></tr></thead><tbody><tr><td style="border: 1px solid black;">原始</td><td style="border: 1px solid black;">[1, 1, 0]</td><td style="border: 1px solid black;">(1 × 5) + (1 × 4) + (0 × 3) = 5 + 4 + 0</td><td style="border: 1px solid black;">9</td></tr><tr><td style="border: 1px solid black;">修改 [0, 1]</td><td style="border: 1px solid black;">[0, 1, 0]</td><td style="border: 1px solid black;">(0 × 5) + (1 × 4) + (0 × 3) = 0 + 4 + 0</td><td style="border: 1px solid black;">4</td></tr><tr><td style="border: 1px solid black;">修改 [1, 2]</td><td style="border: 1px solid black;">[1, 0, 1]</td><td style="border: 1px solid black;">(1 × 5) + (0 × 4) + (1 × 3) = 5 + 0 + 3</td><td style="border: 1px solid black;">8</td></tr></tbody></table>

因此，最大可能利润是 9，无需任何修改即可达成。

**提示：** 

- `2 <= prices.length == strategy.length <= 10^5`
- `1 <= prices[i] <= 10^5`
- `-1 <= strategy[i] <= 1`
- `2 <= k <= prices.length`
- `k` 是偶数

## Solution

## Code

```c++
class Solution {
public:
    long long maxProfit(vector<int>& prices, vector<int>& strategy, int k) {
        long long count=0;
        for(int i = 0 ; i < prices.size(); i++){
            count+=strategy[i]*prices[i];
        }
        int left = 0;
        int mid = 0;
        long long res = 0;
        long long init = 0;
        long long bias = 0;
        for(int right = 0; right< prices.size(); right++){
            init+=strategy[right]*prices[right];
            res+=prices[right];
            if(right-mid+1<k/2)continue;
            long long add = res-init;
            res-=prices[mid];
            mid++;
            if(right-left+1<k)continue;
            bias = max(add, bias);
            init-=strategy[left]*prices[left];
            left++;
        }
        return count+bias;
    }
};
```

