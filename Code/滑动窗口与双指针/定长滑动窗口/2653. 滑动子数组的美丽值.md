# [2653. 滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/description/)

给你一个长度为 `n`的整数数组`nums`，请你求出每个长度为`k`的子数组的 <b>美丽值</b>。

一个子数组的 **美丽值** 定义为：如果子数组中第 `x`**小整数** 是 **负数** ，那么美丽值为第 `x`小的数，否则美丽值为 `0`。

请你返回一个包含`n - k + 1`个整数的数组，**依次** 表示数组中从第一个下标开始，每个长度为`k`的子数组的**美丽值** 。

- 
子数组指的是数组中一段连续 **非空** 的元素序列。

**示例 1：** 

```
<b>输入：</b>nums = [1,-1,-3,-2,3], k = 3, x = 2
<b>输出：</b>[-1,-2,-2]
<b>解释：</b>总共有 3 个 k = 3 的子数组。
第一个子数组是 `[1, -1, -3]` ，第二小的数是负数 -1 。
第二个子数组是 `[-1, -3, -2]` ，第二小的数是负数 -2 。
第三个子数组是 `[-3, -2, 3]，第二小的数是负数 -2 。````

**示例 2：** 

```
<b>输入：</b>nums = [-1,-2,-3,-4,-5], k = 2, x = 2
<b>输出：</b>[-1,-2,-3,-4]
<b>解释：</b>总共有 4 个 k = 2 的子数组。
`[-1, -2] 中第二小的数是负数 -1 。`
`[-2, -3] 中第二小的数是负数 -2 。`
`[-3, -4] 中第二小的数是负数 -3 。`
`[-4, -5] 中第二小的数是负数 -4 。````

**示例 3：** 

```
<b>输入：</b>nums = [-3,1,2,-3,0,-3], k = 2, x = 1
<b>输出：</b>[-3,0,-3,-3,-3]
<b>解释：</b>总共有 5 个 k = 2 的子数组。
`[-3, 1] 中最小的数是负数 -3 。`
`[1, 2] 中最小的数不是负数，所以美丽值为 0 。`
`[2, -3] 中最小的数是负数 -3 。`
`[-3, 0] 中最小的数是负数 -3 。`
`[0, -3] 中最小的数是负数 -3 。````

**提示：** 

- `n == nums.length`
- `1 <= n <= 10^5`
- `1 <= k <= n`
- `1 <= x <= k`
- `-50<= nums[i] <= 50`
```

## Solution

定长滑动窗口=双指针

对窗口内采用的计算方法：单调栈，快排，通排序

## Code

第一版，直接采用快排，时间复杂度平均能达到$O(n^2\log(n))$，因为k最大为n

```c++
class Solution {
public:

    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
        int left = 0;
        deque<int> dq;
        vector<int> res;
        for(int right = 0; right< nums.size(); right++){
            dq.push_back(nums[right]);
            if(right-left+1<k)continue;
            vector<int> tmp(dq.begin(), dq.end());
            sort(tmp.begin(), tmp.end());
            if(tmp[x-1]<0) res.push_back(tmp[x-1]);
            else res.push_back(0);
            dq.pop_front();
            left++;
        }
        return res;
    }
};
```

第二版，用半快排的方法来尝试，时间复杂度平均为$O(n\log(n))$，最差能达到$O(n^2)$，尝试加上随机对换，但是仍然不行

```c++
class Solution {
public:
    int qsort(vector<int> nums, int left, int right, int x){
        int i = left;
        int j = right;
        int mid = (i+j)/2;
        swap(nums[i], nums[mid]);
        int pivot = nums[i];
        while(i<j){
            while(i<j&&pivot<=nums[j]){
                j--;
            }
            while(i<j&&pivot>=nums[i]){
                i++;
            }
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        if(i==x-1){
            if(nums[i]<0)return nums[i];
            else return 0;
        }
        else if(i>x-1){
            return qsort(nums, left, i-1, x);
        }
        else{
            return qsort(nums, i+1, right, x);
        }
    }
    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
        int left = 0;
        deque<int> dq;
        vector<int> res;
        for(int right = 0; right< nums.size(); right++){
            dq.push_back(nums[right]);
            if(right-left+1<k)continue;
            vector<int> tmp(dq.begin(), dq.end());
            res.push_back(qsort(tmp, 0, tmp.size()-1, x));
            dq.pop_front();
            left++;
        }
        return res;
    }
};
```

第三版，看了灵神的一部分思路，觉得可以只记录负数，不考虑正数，可以减少数组长度，时间复杂度平均为$O(n\log(n))$

```c++
class Solution {
public:
    int qsort(vector<int> nums, int left, int right, int x){
        int i = left;
        int j = right;
        int mid = (i+j)/2;
        swap(nums[i], nums[mid]);
        int pivot = nums[i];
        while(i<j){
            while(i<j&&pivot<=nums[j]){
                j--;
            }
            while(i<j&&pivot>=nums[i]){
                i++;
            }
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        if(i==x-1){
            if(nums[i]<0)return nums[i];
            else return 0;
        }
        else if(i>x-1){
            return qsort(nums, left, i-1, x);
        }
        else{
            return qsort(nums, i+1, right, x);
        }
    }
    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
        int left = 0;
        deque<int> dq;
        vector<int> res;
        for(int right = 0; right< nums.size(); right++){
            if(nums[right]<0)dq.push_back(nums[right]);
            if(right-left+1<k)continue;
            vector<int> tmp(dq.begin(), dq.end());
            if(x>tmp.size())res.push_back(0);
            else res.push_back(qsort(tmp, 0, tmp.size()-1, x));
            if(nums[left]<0)dq.pop_front();
            left++;
        }
        return res;
    }
};
```

最后一版，发现样例中可以填充大量负数，达到n个，所以可以直接使用桶排序来记录，桶的最大个数为50个，因此时间复杂度为$O(n)$

```c++
class Solution {
public:

    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
        int left = 0;
        vector<int> cnt(51);
        vector<int> res;
        for(int right = 0; right< nums.size(); right++){
            if(nums[right]<0)cnt[-nums[right]]++;
            if(right-left+1<k)continue;
            int t=0; 
            for(int i = 50; i>0; i--){
                if(cnt[i])t+=cnt[i];
                if(t>=x){
                    res.push_back(-i);
                    break;
                }
            }
            if(t<x)res.push_back(0);
            if(nums[left]<0)cnt[-nums[left]]--;
            left++;
        }
        return res;
    }
};
```

